Create time: 2023-02-24  Last update: 2023-06-27

# How to use the FIT study Note document
1. download the [markdown file repository](https://github.com/GreenH47/mynote) and  navigate to the `docs` folder
2. view all the markdown files via [Obsidian vault](https://help.obsidian.md/How+to/Working+with+multiple+vaults) that can show the linked section in the note document  ![](../img/5032-20221103.png)  
3. You may find some extra material or program template  repository in the Course Brief introduction for the FIT Note markdown Document (some course don't have )

4. you can view [the web page](https://greenh47.github.io/mynote/) which transfer from MD file online but will lose the extra information or wrong    markdown display

  
# FIT5171 System validation and verification, quality and standards Course Brief introduction

## course outline
| week | Introduction                                        |
| ---- | --------------------------------------------------- |
| 1    | Overview of unit & Fundamentals of software testing |
| 2    | Test Planning & Test-driven development             |
| 3    | Discrete mathematics refresher                      |
| 4    | Black box / functional testing                      |
| 5    | White box / structural testing                      |
| 6    | Component testing                                   |
| 7    | Software quality & metrics                          |
| 8    | System testing                                      |
| 9    | Object-oriented testing                             |
| 10   | Software verification and validation techniques     |
| 11   | Revisiting the fundamentals of testing              |

[FIT5171 - System validation and verification, quality and standards - Monash University](https://handbook.monash.edu/2023/units/FIT5171?year=2023) done for the year 2023. (Semester 1)   
![](../img/fit5171-20230228.png)
## git repo for this unit
[GitHub - GreenH47/FIT5171\_2023s1: FIT5171 System validation and verification, quality and standards - S1 2023](https://github.com/GreenH47/FIT5171_2023s1)  
# Note in Pdf version
[FIT5171\_2023s1/exam/fit5171note.pdf at main Â· GreenH47/FIT5171\_2023s1 Â· GitHub](https://github.com/GreenH47/FIT5171_2023s1/blob/main/exam/fit5171note.pdf)  

## What do you need to know before hand?
A solid foundation in software development  
Software Requirements Specification (SRS)  
Software development (Java)  
Software Development Life Cycle (SDLS)  
A good command of discrete mathematics concepts  
This unit covers the core software engineering disciplines concerned with managing and delivering quality software. Topics include processes, tools and techniques for system validation and verification, including major commercial tools used in industry. It shows how to detect, analyse and control defects in complex software systems. Inspection and testing methodologies, analysis of artefacts, robustness, quality assurance, and advanced software validation and verification methods are covered.

## Learning outcomes
1. Explain the importance of quality assurance in software engineering;  
2. Articulate the role of validation and verification methods in the system development life cycle; key issues in software testing, testing levels and testing techniques;  
3. Categorise and apply selection and combination of techniques and test related measures;  
4. Measure, evaluate and analyse software under test using different quality and complexity metrics;  
5. Develop adequate test cases to help detect software system defects using industry-strength IDEs, unit testing frameworks such as JUnit, code coverage tools such as Cobertura, and other similar products;  
6. Implement continuous integration (CI) at unit, integration & system testing level using a CI server such as Jenkins to automatically run regression test suites on the system under test.

# Exam review

Prepare for following weeks thoroughly: 4, 5, 6, 8, 9, 10, 11  
+ Test strategy, test plan, TDD  
+ <mark style="background: #ff0000;">Blackbox Testing (aka functional testing)</mark>
+ Boundary Value Testing (BVT)
+ normal/robust, weak/normal
+ <mark style="background: #ff0000;">Equivalent Class Testing (ECT)</mark>
+ <mark style="background: #3CB371;">Decision Table Testing (DTT)</mark>
+ <mark style="background: #3CB371;">White-box Testing (aka structural testing)</mark>
+ Program graph
+ DD-path graph
+ MM-Path graph
+ Basis Path testing
+ Cyclomatic complexity  


## week 1
### TDD
TDD stands for Test Driven Development, which is a software development process that follows a specific cycle. Here are the steps in the TDD cycle:
å½“ç„¶ï¼TDD ä»£è¡¨ æµ‹è¯• é©±åŠ¨ å¼€å‘ï¼Œ æ˜¯ ä¸€ä¸ª éµå¾ª ç‰¹å®š å‘¨æœŸ çš„ è½¯ä»¶ å¼€å‘ è¿‡ç¨‹ã€‚ä»¥ä¸‹æ˜¯TDDå‘¨æœŸä¸­çš„æ­¥éª¤ï¼š
1. Add a test: The first step in TDD is to write a test. The test should be a small, focused piece of code that verifies a specific behavior or feature of the application.æ·»åŠ æµ‹è¯•ï¼šTDD çš„ç¬¬ä¸€æ­¥æ˜¯ç¼–å†™æµ‹è¯•ã€‚æµ‹è¯•åº”è¯¥æ˜¯ä¸€å°æ®µé‡ç‚¹ä»£ç ï¼Œç”¨äºéªŒè¯åº”ç”¨ç¨‹åºçš„ç‰¹å®šè¡Œä¸ºæˆ–åŠŸèƒ½ã€‚
2. Run the test: Once you have written the test, you should run it to verify that it fails. If it passes, then either the test or the code under test is incorrect.è¿è¡Œæµ‹è¯•ï¼šç¼–å†™æµ‹è¯•åï¼Œåº”è¿è¡Œå®ƒä»¥éªŒè¯å®ƒæ˜¯å¦å¤±è´¥ã€‚å¦‚æœé€šè¿‡ï¼Œåˆ™æµ‹è¯•æˆ–è¢«æµ‹ä»£ç ä¸æ­£ç¡®ã€‚
3. Write the code: After the test fails, you need to write the minimum amount of code required to make the test pass. ç¼–å†™ä»£ç ï¼šæµ‹è¯•å¤±è´¥åï¼Œæ‚¨éœ€è¦ç¼–å†™ä½¿æµ‹è¯•é€šè¿‡æ‰€éœ€çš„æœ€å°‘ä»£ç é‡ã€‚
4. Run all tests: Once you have written the code, you need to run the test suite again to make sure that everything continues to work correctly.è¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼šç¼–å†™ä»£ç åï¼Œéœ€è¦å†æ¬¡è¿è¡Œæµ‹è¯•å¥—ä»¶ä»¥ç¡®ä¿ä¸€åˆ‡ç»§ç»­æ­£å¸¸å·¥ä½œã€‚
5. Refactor the code: Once the test suite is passing, you can then begin to refactor the code to make it more efficient, maintainable, and extensible.é‡æ„ä»£ç ï¼šæµ‹è¯•å¥—ä»¶é€šè¿‡åï¼Œå¯ä»¥å¼€å§‹é‡æ„ä»£ç ï¼Œä½¿å…¶æ›´é«˜æ•ˆã€æ›´æ˜“äºç»´æŠ¤å’Œå¯æ‰©å±•ã€‚ 
6. Repeat: You should then repeat this cycle, adding new tests and features, and refactoring the code as needed until the software is complete.é‡å¤ï¼šç„¶åï¼Œåº”é‡å¤æ­¤å¾ªç¯ï¼Œæ·»åŠ æ–°çš„æµ‹è¯•å’ŒåŠŸèƒ½ï¼Œå¹¶æ ¹æ®éœ€è¦é‡æ„ä»£ç ï¼Œç›´åˆ°è½¯ä»¶å®Œæˆ

### Comparison of different level of testing
![](../img/fit5171-20230614.png)

### TDD: pros & cons 

|AdvantageÂ ä¼˜åŠ¿|Disadvantage|
|---|---|
|More tests, less debugging  <br>æ›´å¤šæµ‹è¯•ï¼Œæ›´å°‘è°ƒè¯•|Difficult in certain scenarios (UI, database, network)  <br>åœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆUIã€æ•°æ®åº“ã€ç½‘ç»œï¼‰å¾ˆéš¾|
|More productiveÂ æ›´é«˜æ•ˆ|Needs management supportÂ éœ€æ±‚ç®¡ç†æ”¯æŒ|
|Validates not only code, but also design  <br>ä¸ä»…éªŒè¯ä»£ç ï¼Œè¿˜éªŒè¯è®¾è®¡|Developer blind spotsÂ å¼€å‘äººå‘˜ç›²ç‚¹|
|Better test coverage, greater confidence  <br>æ›´å¥½çš„æµ‹è¯•è¦†ç›–ç‡ï¼Œæ›´å¤§çš„ä¿¡å¿ƒ|False sense of securityÂ è™šå‡çš„å®‰å…¨æ„Ÿ|
|Better code structureÂ æ›´å¥½çš„ä»£ç ç»“æ„|Maintenance overhead for (bad) tests  <br>ï¼ˆä¸è‰¯ï¼‰æµ‹è¯•çš„ç»´æŠ¤å¼€é”€|

### unit test
A unit test is a type of automated test that is designed to validate the behavior of a single unit of code, typically a method or function. The goal of unit testing is to verify that the code under test works as expected and adheres to its specified requirements.
å•å…ƒæµ‹è¯•æ˜¯ä¸€ç§è‡ªåŠ¨æµ‹è¯•ï¼Œæ—¨åœ¨éªŒè¯å•ä¸ªä»£ç å•å…ƒï¼ˆé€šå¸¸æ˜¯æ–¹æ³•æˆ–å‡½æ•°ï¼‰çš„è¡Œä¸ºã€‚å•å…ƒæµ‹è¯•çš„ç›®æ ‡æ˜¯éªŒè¯å¾…æµ‹è¯•çš„ä»£ç æ˜¯å¦æŒ‰é¢„æœŸå·¥ä½œå¹¶éµå®ˆå…¶æŒ‡å®šçš„è¦æ±‚ã€‚
Unit tests are typically written using a testing framework, which provides a set of tools and methods for defining test cases and verifying their results. In Java, popular testing frameworks include JUnit and TestNG.
å•å…ƒæµ‹è¯•é€šå¸¸ä½¿ç”¨æµ‹è¯•æ¡†æ¶ç¼–å†™ï¼Œè¯¥æ¡†æ¶æä¾›äº†ä¸€ç»„ç”¨äºå®šä¹‰æµ‹è¯•ç”¨ä¾‹å’ŒéªŒè¯å…¶ç»“æœçš„å·¥å…·å’Œæ–¹æ³•ã€‚åœ¨Javaä¸­ï¼Œæµè¡Œçš„æµ‹è¯•æ¡†æ¶åŒ…æ‹¬JUnitå’ŒTestNGã€‚
Unit tests should ideally be written using a suite of repeatable and isolated tests that verify different inputs, edge cases, and outputs. Because unit tests are automated, they are also faster and more reliable than manual testing. They can be executed either as part of a continuous integration pipeline or on-demand during development.
ç†æƒ³æƒ…å†µä¸‹ï¼Œå•å…ƒæµ‹è¯•åº”ä½¿ç”¨ä¸€å¥—å¯é‡å¤å’Œéš”ç¦»çš„æµ‹è¯•æ¥ç¼–å†™ï¼Œè¿™äº›æµ‹è¯•éªŒè¯ä¸åŒçš„è¾“å…¥ã€è¾¹ç¼˜æƒ…å†µå’Œè¾“å‡ºã€‚ç”±äºå•å…ƒæµ‹è¯•æ˜¯è‡ªåŠ¨åŒ–çš„ï¼Œå› æ­¤å®ƒä»¬ä¹Ÿæ¯”æ‰‹åŠ¨æµ‹è¯•æ›´å¿«ã€æ›´å¯é ã€‚å®ƒä»¬å¯ä»¥ä½œä¸ºæŒç»­é›†æˆç®¡é“çš„ä¸€éƒ¨åˆ†æ‰§è¡Œï¼Œä¹Ÿå¯ä»¥åœ¨å¼€å‘æœŸé—´æŒ‰éœ€æ‰§è¡Œã€‚

### Benefits of unit testing
+ Identify defects early (at development time) Otherwise small defects will lead to larger problems  
+ Allows easy defect isolation  
+ Improves confidence of code  
+ Encourage code review

## week 2
### JUnit Basics
JUnit tests are also called test methods in a test class Naming convention of test classes: name of class under test + Test E.g., ShoppingCartTest.java for ShoppingCart.java  
Test names should be meaningful and reflect purpose E.g., shouldReturnTrueWhenUsersHaveSameEmail()

### Test Annotations  
- `@BeforeEach`: This annotation is used to mark a method that should be run before each individual test case. This is typically used to set up any necessary test fixtures or dependencies before running the test.  
    `@BeforeEach`Â ï¼šæ­¤æ³¨é‡Šç”¨äºæ ‡è®°åº”åœ¨æ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¹‹å‰è¿è¡Œçš„æ–¹æ³•ã€‚è¿™é€šå¸¸ç”¨äºåœ¨è¿è¡Œæµ‹è¯•ä¹‹å‰è®¾ç½®ä»»ä½•å¿…è¦çš„æµ‹è¯•å¤¹å…·æˆ–ä¾èµ–é¡¹ã€‚
    
- `@AfterEach`: This annotation is used to mark a method that should be run after each individual test case. This is typically used to clean up any resources that were created during setup, or to reset the state of the system under test.  
    `@AfterEach`Â ï¼šæ­¤æ³¨é‡Šç”¨äºæ ‡è®°åº”åœ¨æ¯ä¸ªå•ç‹¬çš„æµ‹è¯•ç”¨ä¾‹ä¹‹åè¿è¡Œçš„æ–¹æ³•ã€‚è¿™é€šå¸¸ç”¨äºæ¸…ç†åœ¨å®‰è£…è¿‡ç¨‹ä¸­åˆ›å»ºçš„ä»»ä½•èµ„æºï¼Œæˆ–é‡ç½®å—æµ‹ç³»ç»Ÿçš„çŠ¶æ€ã€‚
    
- `@BeforeAll`: This annotation is used to mark a method that should be run once, before any test cases are executed. This is typically used to set up any resources or dependencies that will be used across all tests.  
    `@BeforeAll`Â ï¼šæ­¤æ³¨é‡Šç”¨äºæ ‡è®°åœ¨æ‰§è¡Œä»»ä½•æµ‹è¯•ç”¨ä¾‹ä¹‹å‰åº”è¿è¡Œä¸€æ¬¡çš„æ–¹æ³•ã€‚è¿™é€šå¸¸ç”¨äºè®¾ç½®å°†åœ¨æ‰€æœ‰æµ‹è¯•ä¸­ä½¿ç”¨çš„ä»»ä½•èµ„æºæˆ–ä¾èµ–é¡¹ã€‚
    
- `@AfterAll`: This annotation is used to mark a method that should be run once, after all test cases have been executed. This is typically used to clean up any resources or dependencies that were created in theÂ `@BeforeAll`Â method.  
    `@AfterAll`Â ï¼šæ­¤æ³¨é‡Šç”¨äºæ ‡è®°åœ¨æ‰§è¡Œæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹ååº”è¿è¡Œä¸€æ¬¡çš„æ–¹æ³•ã€‚è¿™é€šå¸¸ç”¨äºæ¸…ç†åœ¨Â `@BeforeAll`Â æ–¹æ³•ä¸­åˆ›å»ºçš„ä»»ä½•èµ„æºæˆ–ä¾èµ–é¡¹ã€‚

### Test Assertions
Assertions allow us to compare expected vs actual behaviours (output values, exceptions, etc.) æ–­è¨€å…è®¸æˆ‘ä»¬æ¯”è¾ƒé¢„æœŸè¡Œä¸ºä¸å®é™…è¡Œä¸ºï¼ˆè¾“å‡ºå€¼ã€å¼‚å¸¸ç­‰ï¼‰
assertTrue() assertFalse()  assertEquals() assertNotEquals()  assertNull() assertNotNull()  assertSame() assertNotSame()  assertArrayEquals() assertThrows()  

### The difference between a test plan and a test strategy
[The difference between a test plan and a test strategy - Inspired Testing](https://www.inspiredtesting.com/news-insights/insights/353-the-difference-between-a-test-plan-and-a-test-strategy#:~:text=vs%20Test%20Plan-,Test%20Plan,testing%20nee)  
  
|Test PlanÂ æµ‹è¯•è®¡åˆ’|Test StrategyÂ æµ‹è¯•ç­–ç•¥|
|---|---|
|A test plan for software project can be defined as a document that defines the scope, objective, approach and emphasis on a software testing effort  <br>è½¯ä»¶é¡¹ç›®çš„æµ‹è¯•è®¡åˆ’å¯ä»¥å®šä¹‰ä¸ºå®šä¹‰è½¯ä»¶æµ‹è¯•å·¥ä½œçš„èŒƒå›´ã€ç›®æ ‡ã€æ–¹æ³•å’Œé‡ç‚¹çš„æ–‡æ¡£|Test strategy is a set of guidelines that explains test design and determines how testing needs to be done  <br>æµ‹è¯•ç­–ç•¥æ˜¯ä¸€ç»„æŒ‡å—ï¼Œç”¨äºè§£é‡Šæµ‹è¯•è®¾è®¡å¹¶ç¡®å®šéœ€è¦å¦‚ä½•è¿›è¡Œæµ‹è¯•|
|Components of Test plan include- Test plan id, features to be tested, test techniques, testing tasks, features pass or fail criteria, test deliverables, responsibilities, and schedule, etc.  <br>æµ‹è¯•è®¡åˆ’çš„ç»„ä»¶åŒ…æ‹¬ - æµ‹è¯•è®¡åˆ’ IDã€è¦æµ‹è¯•çš„åŠŸèƒ½ã€æµ‹è¯•æŠ€æœ¯ã€æµ‹è¯•ä»»åŠ¡ã€åŠŸèƒ½é€šè¿‡æˆ–å¤±è´¥æ ‡å‡†ã€æµ‹è¯•å¯äº¤ä»˜æˆæœã€èŒè´£å’Œæ—¶é—´è¡¨ç­‰ã€‚|Components of Test strategy includes- objectives and scope, documentation formats, test processes, team reporting structure, client communication strategy, etc.  <br>æµ‹è¯•ç­–ç•¥çš„ç»„æˆéƒ¨åˆ†åŒ…æ‹¬ç›®æ ‡å’ŒèŒƒå›´ã€æ–‡æ¡£æ ¼å¼ã€æµ‹è¯•æµç¨‹ã€å›¢é˜ŸæŠ¥å‘Šç»“æ„ã€å®¢æˆ·æ²Ÿé€šç­–ç•¥ç­‰ã€‚|
|Test plan is carried out by a testing manager or lead that describes how to test, when to test, who will test and what to test  <br>æµ‹è¯•è®¡åˆ’ç”±æµ‹è¯•ç»ç†æˆ–ä¸»ç®¡æ‰§è¡Œï¼Œæè¿°å¦‚ä½•æµ‹è¯•ã€ä½•æ—¶æµ‹è¯•ã€è°å°†æµ‹è¯•ä»¥åŠæµ‹è¯•ä»€ä¹ˆ|A test strategy is carried out by the project manager. It says what type of technique to follow and which module to test  <br>æµ‹è¯•ç­–ç•¥ç”±é¡¹ç›®ç»ç†æ‰§è¡Œã€‚å®ƒè¯´æ˜äº†è¦éµå¾ªå“ªç§ç±»å‹çš„æŠ€æœ¯ä»¥åŠè¦æµ‹è¯•çš„æ¨¡å—|
|Test plan narrates about the specification  <br>æµ‹è¯•è®¡åˆ’å™è¿°æœ‰å…³è§„èŒƒ|Test strategy narrates about the general approaches  <br>æµ‹è¯•ç­–ç•¥å™è¿°äº†ä¸€èˆ¬æ–¹æ³•|
|Test plan can changeÂ æµ‹è¯•è®¡åˆ’å¯ä»¥æ›´æ”¹|Test strategy cannot be changed  <br>æ— æ³•æ›´æ”¹æµ‹è¯•ç­–ç•¥|
|Test planning is done to determine possible issues and dependencies in order to identify the risks.  <br>æ‰§è¡Œæµ‹è¯•è®¡åˆ’ä»¥ç¡®å®šå¯èƒ½çš„é—®é¢˜å’Œä¾èµ–é¡¹ï¼Œä»¥ä¾¿è¯†åˆ«é£é™©ã€‚|It is a long-term plan of action.You can abstract information that is not project specific and put it into test approach  <br>è¿™æ˜¯ä¸€é¡¹é•¿æœŸè¡ŒåŠ¨è®¡åˆ’ã€‚æ‚¨å¯ä»¥æŠ½è±¡å‡ºéé¡¹ç›®ç‰¹å®šçš„ä¿¡æ¯å¹¶å°†å…¶æ”¾å…¥æµ‹è¯•æ–¹æ³•|
|A test plan exists individually  <br>å•ç‹¬å­˜åœ¨æµ‹è¯•è®¡åˆ’|In smaller projects, the test strategy is often found as a section of a test plan  <br>åœ¨è¾ƒå°çš„é¡¹ç›®ä¸­ï¼Œæµ‹è¯•ç­–ç•¥é€šå¸¸ä½œä¸ºæµ‹è¯•è®¡åˆ’çš„ä¸€éƒ¨åˆ†ã€‚|
|It is defined at project level  <br>å®ƒæ˜¯åœ¨é¡¹ç›®çº§åˆ«å®šä¹‰çš„|It is set at organization level and can be used by multiple projects  <br>å®ƒæ˜¯åœ¨ç»„ç»‡çº§åˆ«è®¾ç½®çš„ï¼Œå¯ä»¥ç”±å¤šä¸ªé¡¹ç›®ä½¿ç”¨|

## week 3 Discrete maths
### label 
+ And(âˆ§) ä¸ï¼›ä¸”  
+ Or(âˆ¨) æˆ–  
+ Implies(â‡’) å®è´¨è•´å«  
+ Equiv(â‡”)å®è´¨ç­‰ä»·  
+ âŠ¢ æ¨å¯¼å‡º 
![AltText|300x200](../img/fit5171-20230313.png )
### Predicate Logics è°“è¯é€»è¾‘
+ Universal (âˆ€) ä»»æ„  
+ existential (âˆƒ) å­˜åœ¨  
+ Setï¼ˆPï¼‰é›†åˆ  
+ âˆƒx (P(x) â‹€ Q(x)) åœ¨Pï¼ŒQä¸¤ä¸ªé›†åˆä¸­éƒ½å­˜åœ¨x
### set 
+ æ— é¡ºåºï¼Œä¸é‡å¤ == Javaé‡çš„setæ¦‚å¿µ  
+ {1,2,3,4}  {x : N | x â‰¤ 64}  
+ Nï¼šéè´Ÿæ•´æ•°é›†åˆæˆ–è‡ªç„¶æ•°é›†åˆ{0,1,2,3,...}  
+ Zï¼šæ•´æ•°é›†åˆ{...,-1,0,1,...}  
+ Qï¼šæœ‰ç†æ•°é›†åˆ  
+ Rï¼šå®æ•°é›†åˆ(åŒ…æ‹¬æœ‰ç†æ•°å’Œæ— ç†æ•°ï¼‰  
+ âˆ… ï¼šç©ºé›†ï¼ˆä¸å«æœ‰ä»»ä½•å…ƒç´ çš„é›†åˆï¼‰  
+ N*æˆ–N+ï¼šæ­£æ•´æ•°é›†åˆ{1,2,3,...}
+ Membership: å±äº  
+ Set inclusion:  Subset: å­é›†  Proper subset:çœŸå­é›†  
+ Set cardinality:  `#A` = 3 é›†åˆå…ƒç´ ä¸ªæ•° ï½œAï½œ
+ ![AltText|300x200](../img/fit5171-20230614-3.png)  
### Power set P
A power set is set of all subsets, empty set and the original set itself å¹‚é›†æ˜¯æ‰€æœ‰å­é›†ã€ç©ºé›†å’ŒåŸå§‹é›†æœ¬èº«çš„é›†åˆ   
+ $âˆ€X â€¢ X$   is a set, $Px = {A|A âŠ† X}$  
+ for every X, Px (which is defined as the set of all subsets of X) is a set.å¯¹äºæ¯ä¸ª Xï¼ŒPxï¼ˆå®šä¹‰ä¸º X çš„æ‰€æœ‰å­é›†çš„é›†åˆï¼‰æ˜¯ä¸€ä¸ªé›†åˆã€‚
+ power set of A = {1, 2} is P(A) = {{}, {1}, {2}, {1, 2}}

### Set operations é›†åˆè¿ç®—
+ Unionå¹¶é›† : $A ğ•Œ B$  The set containing all the elements of  which all other sets are subs
+ Intersectionäº¤é›† : $Aâˆ©B$  Items common in A,B
+ Difference : å·®é›† A - B; A = {1, 2, 3, 4, 5, 6} and B = {3, 4, 5, 6, 7, 8},A â€“ B = {1, 2},B â€“ A = {7, 8},
+ Cartesian productç¬›å¡å°”ç§¯ : `{a, b} â‡¥ {0, 1} = {(a, 0), (a, 1), (b, 0), (b, 1)}`

### Relations ( â‡”) ä¸¤ä¸ªé›†åˆé—´çš„é€»è¾‘è”ç³»
Relations (R) are defined over sets  A relation is a collection of ordered pairs, which  contains an object from one set to the other set å…³ç³» (R) æ˜¯åœ¨é›†åˆä¸Šå®šä¹‰çš„ å…³ç³»æ˜¯æœ‰åºå¯¹çš„é›†åˆï¼Œå…¶ä¸­åŒ…å«ä»ä¸€ä¸ªé›†åˆåˆ°å¦ä¸€ä¸ªé›†åˆçš„å¯¹è±¡ Can be one-to-one, one-to-many  or many-to-one, many-to-many  
The Cartesian product deals with ordered pairs, so  the order in which the sets are considered is ç¬›å¡å°”ç§¯å¤„ç†æœ‰åºå¯¹ï¼Œå› æ­¤è€ƒè™‘é›†åˆçš„é¡ºåºæ˜¯  `friends : Person â‡” Person`  
$X Ñ… Y = {(x, y)} | x âˆˆ X and y âˆˆ Y} Where X Ñ… Y â‰  Y Ñ… X$  
Using n(A) for the number of elements in a set A, we have $n(X Ñ… Y) = n(X) Ñ… n(Y)$ 

### functions (â†’ )
å‡½æ•°æ˜¯ä¸€ç§ç‰¹æ®Šçš„å…³ç³»ç±»å‹ã€‚è¿™ç§ç‰¹æ®Šç±»å‹çš„å…³ç³»æè¿°äº†ä¸€ä¸ªå…ƒç´ å¦‚ä½•æ˜ å°„åˆ°å¦ä¸€ä¸ªé›†åˆæˆ–åŒä¸€ä¸ªé›†åˆä¸­çš„å¦ä¸€ä¸ªå…ƒç´   
It is a relation that defines the set of  inputs to the set of outputs.  Note that all functions are relations, but  not all relations are functions å®ƒæ˜¯å®šä¹‰è¾“å…¥é›†åˆ°è¾“å‡ºé›†çš„å…³ç³»ã€‚è¯·æ³¨æ„ï¼Œæ‰€æœ‰å‡½æ•°éƒ½æ˜¯å…³ç³»ï¼Œä½†å¹¶éæ‰€æœ‰å…³ç³»éƒ½æ˜¯å‡½æ•°  
`â†’ `  implies/ when used in functions, it  symbolises mapping Aâ†’B, if A is true then B is also true.  If A is false then nothing said about  B  
`age : Person N`  `birthday : Person â†’ Date`  

### Undirected graphs æ— å‘å›¾
![AltText|300x00](../img/fit5171-20230614-4.png)  
$G = (V, E)$  å®šä¹‰ç§°äºŒå…ƒç»„G=(V,E)æ˜¯ä¸€ä¸ªæ— å‘å›¾(undirected graph)
+ <mark style="background: #ff0000;">V: a non-empty set of nodes {n1, n2 , n3, ..., nm }</mark>   Væ˜¯ä¸€ä¸ªéç©ºæœ‰é™é›†åˆ 
+ <mark style="background: #ff0000;">E: a set of edges {e1, e2, ..., ep}, where each ek = (ni, nj)</mark>  Eæ˜¯Vä¸­å…ƒç´ çš„æ— åºå¯¹æ‰€ç»„æˆçš„é›†åˆ  
+ æŠŠVçš„å…ƒç´ å«åšå›¾çš„é¡¶ç‚¹ (vertex)ï¼ŒEçš„å…ƒç´ å«åšå›¾çš„è¾¹ (edge)ã€‚V(G)è¡¨ç¤ºå›¾Gçš„é¡¶ç‚¹é›†ï¼ŒE(G)è¡¨ç¤ºå›¾Gçš„è¾¹é›†ã€‚è‹¥ |V(G)|=nï¼Œåˆ™ç§°Gä¸ºné˜¶å›¾  
#### Representation & Degree
`V = {n 1 , n 2 , n 3 , n 4 , n 5 , n 6 , n 7}`  
`E = {e1 , e2 , e3 , e4 , e 5 , } = {(n 1 , n 2 ), (n 1 , n 4 ), (n 2 , n 5 ), (n 3 , n 4 ), (n 4 , n 6 )}`  
<mark style="background: #0000CD;">Degree of node : No. of edges that have that node as  an endpoint</mark>  
`degree(n 1 ) = 2, degree(n 4 ) = 3,  degree(n 7 ) = 0`  
+ Degree åº¦ï¼Œ èŠ‚ç‚¹è¾¹çš„æ•°é‡ ï¼ˆç¯ç®—ä½œä¸¤æ¡è¾¹ï¼‰  
+ Pathè·¯å¾„ï¼Œå¤šæ¡ç›¸è¿çš„è¾¹çš„ç»„åˆ Nodes ni and nj are connected if they  are in a path.  A component is a maximal set of  connected node å¦‚æœèŠ‚ç‚¹ ni å’Œ nj åœ¨ä¸€æ¡è·¯å¾„ä¸­ï¼Œåˆ™å®ƒä»¬æ˜¯è¿é€šçš„ åˆ†é‡æ˜¯è¿é€šèŠ‚ç‚¹çš„æœ€å¤§é›†åˆ `Path(n1,n5) = (n1, n2, n5) = <e1,  e4>` 
### Directed graphs æœ‰å‘å›¾
![AltText|300x00](../img/fit5171-20230614-5.png)
+ å¤´/åŸç‚¹ Sourceï¼Œ indgree = 0  
+ ç»ˆç‚¹ Sinkï¼Œ outdgree = 0  
+ å…¥åº¦ indgree æ±‡å…¥èŠ‚ç‚¹çš„è¾¹çš„æ•°é‡  
+ å‡ºåº¦ outdgree ä»èŠ‚ç‚¹å¼•å‡ºçš„è¾¹çš„æ•°é‡
#### Semi -Paths
![t|300x00](../img/fit5171-20230614-6.png)
#### n-Connectedness
![t|300x00](../img/fit5171-20230614-7.png)
#### Strongly connected components å¼ºè¿é€šåˆ†é‡
![t|300x00](../img/fit5171-20230614-8.png)

### McCabeâ€™s Cyclomatic complexityåœˆå¤æ‚åº¦ 
[Cyclomatic Complexity in Software Testing (Example)](https://www.guru99.com/cyclomatic-complexity.html)  
[Cyclomatic Complexity - GeeksforGeeks](https://www.geeksforgeeks.org/cyclomatic-complexity/)  
åœˆå¤æ‚åº¦ï¼ˆCyclomatic Complexityï¼‰æ˜¯è¡¡é‡è®¡ç®—æœºç¨‹åºå¤æ‚ç¨‹åº¦çš„ä¸€ç§æªæ–½ã€‚å®ƒæ ¹æ®ç¨‹åºä»å¼€å§‹åˆ°ç»“æŸçš„çº¿æ€§ç‹¬ç«‹è·¯å¾„çš„æ•°é‡è®¡ç®—å¾—æ¥çš„.åœˆå¤æ‚åº¦è¶Šé«˜ï¼Œä»£ç å°±è¶Šéš¾å¤æ‚éš¾ç»´æŠ¤ã€‚å‘å°±è¶Šå¤§ã€‚
è®¡ç®—å…¬å¼1ï¼šV(G)=E-N+2Pã€‚å…¶ä¸­ï¼ŒEè¡¨ç¤ºæ§åˆ¶æµå›¾ä¸­è¾¹çš„æ•°é‡ï¼ŒNè¡¨ç¤ºæ§  åˆ¶æµå›¾ä¸­èŠ‚ç‚¹çš„æ•°é‡ï¼ŒPå›¾çš„è¿æ¥ç»„ä»¶æ•°ç›®ï¼ˆå›¾çš„ç»„ä»¶æ•°æ˜¯ç›¸è¿èŠ‚ç‚¹çš„æœ€å¤§é›†åˆï¼‰
`(G) = #E - #V + p` â€” Strongly connected graph  
`V(G) = #E - #V + 2p` â€” Not strongly connected graph  
![t|400x300](../img/fit5171-20230614-9.png)
The cyclomatic complexity calculated for above code will be from control flow graph. The graph shows seven shapes(nodes), seven lines(edges), hence cyclomatic complexity is 7-7+2 = 2.Â   ä¸ºä¸Šè¿°ä»£ç è®¡ç®—çš„åœˆå¤æ‚åº¦å°†æ¥è‡ªæ§åˆ¶æµå›¾ã€‚è¯¥å›¾æ˜¾ç¤ºäº†ä¸ƒä¸ªå½¢çŠ¶ï¼ˆèŠ‚ç‚¹ï¼‰ï¼Œä¸ƒä¸ªçº¿ï¼ˆè¾¹ï¼‰ï¼Œå› æ­¤åœˆå¤æ‚åº¦ä¸º 7-7+2 = 2ã€‚
```
If (Condition 1)
Statement 1

Else
Statement 2

If (Condition 2)
Statement 3

Else
Statement 4
```
+ Nodes (N): èŠ‚ç‚¹ ï¼ˆNï¼‰ï¼šThere are 6 nodes in the control flow graph.æ§åˆ¶æµå›¾ä¸­æœ‰ 6 ä¸ªèŠ‚ç‚¹ã€‚
+ Edges (E): è¾¹ç¼˜ ï¼ˆEï¼‰ï¼šThere are 7 edges in the control flow graph.æ§åˆ¶æµå›¾ä¸­æœ‰ 7 æ¡è¾¹ã€‚
+ Connected components (P):è¿æ¥çš„ç»„ä»¶ ï¼ˆPï¼‰There is 1 connected component in the control flow graph.æ§åˆ¶æµå›¾ä¸­æœ‰ 1 ä¸ªè¿æ¥çš„ç»„ä»¶ã€‚
+ M = E - N + 2P = 7 - 6 + 2(1) = 3
+ Therefore, the cyclomatic complexity of this code is 3. This value represents the number of independent paths through the code, and can be used to estimate the number of test cases needed to achieve full code coverage. In this case, we determined that at least 4 test cases are needed to cover all possible branches, which is consistent with the cyclomatic complexity metric of 3.å› æ­¤ï¼Œæ­¤ä»£ç çš„åœˆå¤æ‚åº¦ä¸º 3ã€‚æ­¤å€¼è¡¨ç¤ºé€šè¿‡ä»£ç çš„ç‹¬ç«‹è·¯å¾„æ•°ï¼Œå¯ç”¨äºä¼°è®¡å®ç°å®Œæ•´ä»£ç è¦†ç›–æ‰€éœ€çš„æµ‹è¯•ç”¨ä¾‹æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç¡®å®šè‡³å°‘éœ€è¦ 4 ä¸ªæµ‹è¯•ç”¨ä¾‹æ¥è¦†ç›–æ‰€æœ‰å¯èƒ½çš„åˆ†æ”¯ï¼Œè¿™ä¸åœˆå¤æ‚åº¦åº¦é‡ 3 ä¸€è‡´ã€‚

This metric is useful because of properties of Cyclomatic complexity (M) â€“  
ç”±äºåœˆå¤æ‚åº¦ ï¼ˆMï¼‰ â€“
1. M can be number of test cases to achieve branch coverage (Upper Bound)  
    Må¯ä»¥æ˜¯æµ‹è¯•ç”¨ä¾‹çš„æ•°é‡ï¼Œä»¥å®ç°åˆ†æ”¯è¦†ç›–ï¼ˆä¸Šé™ï¼‰
2. M can be number of paths through the graphs. (Lower Bound)  
    M å¯ä»¥æ˜¯é€šè¿‡å›¾å½¢çš„è·¯å¾„æ•°ã€‚ï¼ˆä¸‹é™ï¼‰


![t|400x00](../img/fit5171-20230614-10.png)
## week 4
### é»‘ç›’æµ‹è¯• Blackbox
1. é»‘ç›’ä»£è¡¨ç›’å­æ˜¯ä¸é€æ˜çš„  
2. å…³æ³¨è¾“å…¥å’Œè¾“å‡ºï¼Œè€Œå¿½ç•¥ç›’å­é‡Œé¢çš„æ“ä½œ  
3. æœ‰Functional å’ŒNon-functionalä¹‹åˆ† Functional ï¼šå…·ä½“åŠŸèƒ½ï¼Œç™»é™†ï¼Œæ³¨å†Œç­‰  Non-Functionalï¼šç¨³å®šæ€§ï¼Œå®‰å…¨æ€§ï¼Œæ˜“ç”¨æ€§ç­‰  
4. Equivalence Partitioning  Testers can divide possible inputs into groups or â€œpartitionsâ€ 
5. Boundary Value Analysis  Testers can identify that a system has a special response around a specific boundary value.  
6. Decision Table Testing  Many systems provide outputs based on a set of conditions.
### Normal Boundary Value Testing (NBVT) è¾¹ç•Œå€¼æµ‹è¯•
![t|400x00](../img/fit5171-20230614-11.png)
### Robustness testing
For each variable, we need to test its minimum and maximum values, which gives us 2n test cases. The total number of test cases required for the robust version of BVT is: 2n (minimum and maximum values) + 4n + 1 (normal values) å¯¹äºæ¯ä¸ªå˜é‡ï¼Œæˆ‘ä»¬éœ€è¦æµ‹è¯•å®ƒçš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œè¿™ç»™äº†æˆ‘ä»¬ 2n ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚å¥å£®ç‰ˆBVTæ‰€éœ€çš„æµ‹è¯•ç”¨ä¾‹æ€»æ•°ä¸ºï¼š2nï¼ˆæœ€å°å€¼å’Œæœ€å¤§å€¼ï¼‰+4n+1ï¼ˆæ­£å¸¸å€¼ï¼‰
![t|400x00](../img/fit5171-20230614-12.png)
### Worst case testing
![t|400x00](../img/fit5171-20230614-13.png)
### Robust worst-case testing
![t|400x00](../img/fit5171-20230614-14.png)
### Equivalence class testing ç­‰ä»·ç±»æµ‹è¯•
![t|400x00](../img/fit5171-20230614-15.png)
![t|400x00](../img/fit5171-20230614-16.png)
### weak normal equivalence class testing
Let Cx denote the equivalence classes of valid values for variable x (Cx is a set of equivalence classes). Then the number of test cases is max (#Cxi ), for xi ranging over all variables. That is, the maximum number of equivalence classes for all variables ä»¤ Cx è¡¨ç¤ºå˜é‡ x çš„æœ‰æ•ˆå€¼çš„ç­‰ä»·ç±»ï¼ˆCx æ˜¯ä¸€ç»„ç­‰ä»·ç±»ï¼‰ã€‚é‚£ä¹ˆæµ‹è¯•ç”¨ä¾‹çš„æ•°é‡æ˜¯æœ€å¤§çš„ï¼ˆ#Cxiï¼‰ï¼Œå› ä¸º xi éåŠæ‰€æœ‰å˜é‡ã€‚å³æ‰€æœ‰å˜é‡çš„æœ€å¤§ç­‰ä»·ç±»æ•°  

### Weak robust equivalence class testing.
We assume the same settings as in the previous question. Let Ixi denote the  equivalence classes of invalid values for variable xi . Let n denote the number of variables.  the number of tests is max (#Cxi ) +  nXi=1(#Ixi ), for xi ranging over all variables. Basically, we include also the total number of test cases in the invalid areas for each variable. Note that cardinality of Ixi may not always be 2 since there may be gaps between valid equivalence classes  æˆ‘ä»¬é‡‡ç”¨ä¸ä¸Šä¸€ä¸ªé—®é¢˜ç›¸åŒçš„è®¾ç½®ã€‚è®¾ Ixi è¡¨ç¤ºå˜é‡ xi çš„æ— æ•ˆå€¼çš„ç­‰ä»·ç±»ã€‚è®¾ n è¡¨ç¤ºå˜é‡çš„æ•°é‡ã€‚æµ‹è¯•æ¬¡æ•°ä¸º max (#Cxi ) + nX i=1 (#Ixi )ï¼Œxi éåŠæ‰€æœ‰å˜é‡ã€‚åŸºæœ¬ä¸Šï¼Œæˆ‘ä»¬è¿˜åŒ…æ‹¬æ¯ä¸ªå˜é‡çš„æ— æ•ˆåŒºåŸŸä¸­çš„æµ‹è¯•ç”¨ä¾‹æ€»æ•°ã€‚è¯·æ³¨æ„ï¼ŒIxi çš„åŸºæ•°å¯èƒ½å¹¶ä¸æ€»æ˜¯ 2ï¼Œå› ä¸ºæœ‰æ•ˆç­‰ä»·ç±»ä¹‹é—´å¯èƒ½å­˜åœ¨é—´éš™

### Decision table Testing
![t|400x00](../img/fit5171-20230614-17.png)
#### how to make dtt
in the example each of the three variables a, b and c is the length of a side from the range `[1, 200]`. Come up with test cases for weak normal equivalenceclass testing that cover the same expected outputs åœ¨ç¤ºä¾‹ä¸­ï¼Œä¸‰ä¸ªå˜é‡ aã€b å’Œ c ä¸­çš„æ¯ä¸€ä¸ªéƒ½æ˜¯èŒƒå›´ [1, 200] ä¸­çš„è¾¹çš„é•¿åº¦ã€‚æå‡ºæ¶µç›–ç›¸åŒé¢„æœŸè¾“å‡ºçš„å¼±æ­£æ€ç­‰ä»·ç±»æµ‹è¯•çš„æµ‹è¯•ç”¨ä¾‹  
equivalence classes:  
+ D1 = {(a, b, c) | a = b = c}  
+ D2 = {(a, b, c) | a = b âˆ§ aÌ¸ = c âˆ§ c < a + b}  
+ D3 = {(a, b, c) | aÌ¸ = b âˆ§ aÌ¸ = c âˆ§ bÌ¸ = c âˆ§ a < b + c âˆ§ b < a + c âˆ§ c < a + b}  
+ D4 = {(a, b, c) | a = b + c}  
+ D5 = {(a, b, c) | a > b + c}
![t|400x00](../img/fit5171-20230618-6.png)  

### testing effort
![t|400x00](../img/fit5171-20230614-18.png)

### Difference Between Equivalence Class Testing & Boundary Value Analysis:
[Equivalence Class Testing: Complete Guide |Professionalqa.com](https://www.professionalqa.com/equivalence-class-testing)  

|Equivalence Class Testing  <br>ç­‰æ•ˆç­‰çº§æµ‹è¯•|Boundary Value AnalysisÂ è¾¹ç•Œå€¼åˆ†æ|
|---|---|
|1. Equivalence Class Testing is a type of black box technique.  <br>1. ç­‰æ•ˆç±»æµ‹è¯•æ˜¯ä¸€ç§é»‘ç›’æŠ€æœ¯ã€‚|1. Next part of Equivalence Class Partitioning/Testing.  <br>1. ç­‰æ•ˆç±»åˆ†åŒº/æµ‹è¯•çš„ä¸‹ä¸€éƒ¨åˆ†ã€‚|
|2. It can be applied to any level of testing, like unit, integration, system, and more.  <br>2.å®ƒå¯ä»¥åº”ç”¨äºä»»ä½•çº§åˆ«çš„æµ‹è¯•ï¼Œå¦‚å•å…ƒï¼Œé›†æˆï¼Œç³»ç»Ÿç­‰ã€‚|2. Boundary value analysis is usually a part of stress & negative testing.  <br>2. è¾¹ç•Œå€¼åˆ†æé€šå¸¸æ˜¯å‹åŠ›å’Œè´Ÿæµ‹è¯•çš„ä¸€éƒ¨åˆ†ã€‚|
|3. A test case design technique used to divide input data into different equivalence classes.  <br>3. ä¸€ç§æµ‹è¯•ç”¨ä¾‹è®¾è®¡æŠ€æœ¯ï¼Œç”¨äºå°†è¾“å…¥æ•°æ®åˆ’åˆ†ä¸ºä¸åŒçš„ç­‰ä»·ç±»ã€‚|3. This test case design technique used to test boundary value between partitions.  <br>3. æ­¤æµ‹è¯•ç”¨ä¾‹è®¾è®¡æŠ€æœ¯ç”¨äºæµ‹è¯•åˆ†åŒºä¹‹é—´çš„è¾¹ç•Œå€¼ã€‚|
|4. Reduces the time of testing, while using less and effective test cases.  <br>4.å‡å°‘æµ‹è¯•æ—¶é—´ï¼ŒåŒæ—¶ä½¿ç”¨æ›´å°‘å’Œæœ‰æ•ˆçš„æµ‹è¯•ç”¨ä¾‹ã€‚|4. Reduces the overall time of test execution, while making defect detection faster & easy.  <br>4. å‡å°‘æµ‹è¯•æ‰§è¡Œçš„æ€»æ—¶é—´ï¼ŒåŒæ—¶ä½¿ç¼ºé™·æ£€æµ‹æ›´å¿«ã€æ›´å®¹æ˜“ã€‚|
|5. Tests only one from each partition of the equivalence classes.  <br>5. ä»ç­‰æ•ˆç±»çš„æ¯ä¸ªåˆ†åŒºä¸­ä»…æµ‹è¯•ä¸€ä¸ªã€‚|5. Selects test cases from the edges of the equivalence classes.  <br>5. ä»ç­‰æ•ˆç±»çš„è¾¹ç¼˜é€‰æ‹©æµ‹è¯•ç”¨ä¾‹ã€‚|
## week 5
### ç™½ç›’æµ‹è¯• Whitebox  
1. ç™½ç›’ä»£è¡¨ç›’å­æ˜¯é€æ˜çš„  
2. ä¸ä»…å…³æ³¨è¾“å…¥å’Œè¾“å‡ºï¼ŒåŒæ—¶å…³æ³¨ç›’å­å†…çš„ä»£ç ç»“æ„  
3. Testing structure of the software  
4. å°†ä»£ç è½¬æ¢æˆæ•°å­¦æ¨¡å‹
### Program graph
1. æœ‰å‘å›¾  
2. ç‚¹Nodeä»£è¡¨ Statement  
3. è¾¹Edgeä»£è¡¨ Flow  
4. å¤šè¡ŒStatementå¯æµ“ç¼©
![t|400x00](../img/fit5171-20230614-20.png)
### DD-path ï¼ˆDecision-to-decision path å†³ç­–åˆ°å†³ç­–è·¯å¾„ï¼‰  
ä¸»è¦ç€çœ¼æµ‹è¯•è¦†ç›–ç‡é—®é¢˜ã€‚ç¨‹åºæœ‰å‘å›¾ä¸­å­˜åœ¨åˆ†æ”¯ï¼Œè¦†ç›–ç‡è€ƒè™‘çš„æ˜¯å¯¹å„ä¸ªåˆ†æ”¯æƒ…å†µçš„æµ‹è¯•è¦†ç›–ç¨‹åº¦ï¼Œå› æ­¤å¯¹æœ‰å‘å›¾ä¸­çº¿æ€§ä¸²è¡Œçš„éƒ¨åˆ†è¿›è¡Œå‹ç¼©ï¼Œåœ¨å‹ç¼©å›¾(å³DD-è·¯å¾„)çš„åŸºç¡€ä¸Šè¿›è¡Œæµ‹è¯•ç”¨ä¾‹è®¾è®¡ï¼Œç”¨æµ‹è¯•è¦†ç›–æŒ‡æ ‡è€ƒå¯Ÿæµ‹è¯•æ•ˆæœ 
![t|400x00](../img/fit5171-20230614-21.png)  
###  Basic Path Test åŸºç¡€è·¯å¾„æµ‹è¯• - æ‰¾å‡ºæœ€ä½³æµ‹è¯•è·¯å¾„
![t|400x00](../img/fit5171-20230614-22.png)
## week6
### Functional decomposition åŠŸèƒ½åˆ†è§£ / Block Diagram æ¨¡å—å›¾
1. æ¯ä¸€ä¸ªæ–¹å—ä»£è¡¨äº†ç³»ç»Ÿä¸­ä¸€ç§åŠŸèƒ½  
2. æ˜¯è½¯ä»¶è®¾è®¡çš„ç¬¬ä¸€ä¸ªè‰å›¾  
![t|400x00](../img/fit5171-20230615.png)
### Integration Testing
1. System - hierarchically composed of units  
2. Objectives - testing of interfacing and interaction of units To expose problems arising from the combination To find a working solution from components  
3. é›†æˆæµ‹è¯•æ˜¯åœ¨å•å…ƒæµ‹è¯•çš„åŸºç¡€ä¸Šï¼Œæµ‹è¯•åœ¨å°†æ‰€æœ‰çš„è½¯ä»¶å•å…ƒæŒ‰ç…§æ¦‚è¦è®¾è®¡è§„æ ¼è¯´æ˜çš„è¦æ±‚ç»„è£…æˆæ¨¡å—ã€å­ç³»ç»Ÿæˆ–ç³»ç»Ÿçš„è¿‡ç¨‹ä¸­å„éƒ¨åˆ†å·¥ä½œæ˜¯å¦è¾¾åˆ°æˆ–å®ç°ç›¸åº”æŠ€æœ¯æŒ‡æ ‡åŠè¦æ±‚çš„æ´»åŠ¨ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨é›†æˆæµ‹è¯•ä¹‹å‰ï¼Œå•å…ƒæµ‹è¯•åº”è¯¥å·²ç»å®Œæˆ,é›†æˆæµ‹è¯•ä¸­æ‰€ä½¿ç”¨çš„å¯¹è±¡åº”è¯¥æ˜¯å·²ç»ç»è¿‡å•å…ƒæµ‹è¯•çš„è½¯ä»¶å•å…ƒ
#### Potential hazards
+ Internal - between components (Method invocation; Parameter; Method return) å•å…ƒé—´çš„æ¥å£ï¼ŒæŒ‡çš„æ˜¯ä»£ç é—´çš„ç›¸äº’è°ƒç”¨ï¼Œæˆ‘ä»¬ä¼ é€’ä¸€äº›å‚æ•°æ¥åˆ¤æ–­æµ‹è¯•è°ƒç”¨æœ‰æ²¡æœ‰é—®é¢˜  
+ Interaction - at system boundary é›†æˆåçš„åŠŸèƒ½ï¼Œä¸åŒçš„åŠŸèƒ½ä¹‹é—´æ˜¯å¦ä¼šäº§ç”Ÿç›¸äº’å½±å“ï¼Ÿ
### Integration testing approaches
#### Decomposition-based åŸºäºåˆ†è§£ï¼ŒåŠŸèƒ½åˆ†è§£ï¼Œæ¨¡å—åˆ†è§£  
1. Big bang - all units together, no error localisation  å¤§çˆ†ç‚¸ç­–ç•¥ ä¸€èµ·è¿è¡Œ è¿…é€Ÿ ä¸€æ¬¡è¯•è¿è¡ŒæˆåŠŸç‡ä¸å¤§ é—®é¢˜å®šä½å’Œä¿®æ”¹éƒ½æ¯”è¾ƒå›°éš¾ åŠŸèƒ½å¢å¼ºå‹é¡¹ç›®
2. Top down - stubs, early demo  ä»ä¸Šè‡³ä¸‹ è¾ƒæ—©çš„éªŒè¯äº†ä¸»è¦çš„æ§åˆ¶å’Œåˆ¤æ–­ç‚¹ é¦–å…ˆå®ç°å’ŒéªŒè¯ä¸€ä¸ªå®Œæ•´çš„è½¯ä»¶åŠŸèƒ½ æ¡©çš„å¼€å‘å’Œç»´æŠ¤æ—¶æœ¬ç­–ç•¥å¤§ åº•å±‚ç»„ä»¶çš„æµ‹è¯•ä¸å¤Ÿå……åˆ† é€‚åˆäº§å“æ§åˆ¶ç»“æ„ç›¸å¯¹æ¸…æ™°å’Œç¨³å®šï¼Œäº§å“çš„é«˜å±‚æ¥å£å˜åŒ–æ¯”è¾ƒå°ï¼Œäº§å“çš„åº•å±‚æ¥å£æœªå®šä¹‰æˆ–è€…ç»å¸¸å¯èƒ½è¢«ä¿®æ”¹ï¼Œäº§å“çš„æ§åˆ¶ç»„ä»¶å…·æœ‰è¾ƒå¤§çš„æŠ€æœ¯é£é™©ï¼Œéœ€è¦å°½æ—©çš„è¢«éªŒè¯
3. Bottom up - terminal, drivers  ä»ä¸‹è‡³ä¸Š é›†æˆæµ‹è¯•å¼€å§‹é˜¶æ®µå¯èƒ½ä¼šå¹¶è¡Œçš„è¿›è¡Œé›†æˆ é©±åŠ¨çš„å¼€å‘å·¥ä½œé‡ä¹Ÿå¾ˆåºå¤§ã€‚å¯¹äºé«˜å±‚çš„éªŒè¯è¢«æ¨è¿Ÿåˆ°äº†æœ€åï¼Œè®¾è®¡ä¸Šçš„é”™è¯¯ä¸èƒ½è¢«åŠæ—¶å‘ç° é€‚ç”¨èŒƒå›´ åº•å±‚æ¥å£æ¯”è¾ƒç¨³å®šã€å˜åŠ¨è¾ƒå°‘çš„äº§å“é«˜å±‚æ¥å£å˜åŒ–æ¯”è¾ƒé¢‘ç¹çš„äº§å“åº•å±‚ç»„ä»¶è¾ƒæ—©è¢«å®Œæˆçš„äº§å“
4.  Sandwich - a combination of the above 2  åœ¨æµ‹è¯•çš„æ—¶å€™ï¼Œå¯¹ç›®æ ‡å±‚çš„ä¸Šä¸€å±‚ä½¿ç”¨è‡ªé¡¶å‘ä¸‹çš„é›†æˆç­–ç•¥å¯¹ç›®æ ‡çš„ä¸‹ä¸€å±‚ä½¿ç”¨è‡ªåº•å‘ä¸Šçš„é›†æˆç­–ç•¥ï¼Œæœ€åæµ‹è¯•åœ¨ç›®æ ‡å±‚ä¼šåˆ

#### Call graph-based  
1. Pairwise integration   Instead of testing all possible combinations of inputs, pairwise integration testing only tests combinations of input pairs. identify defects or issues that arise due to the interactions between two components, while minimizing the number of test cases needed. æˆå¯¹é›†æˆæµ‹è¯•çš„ç›®æ ‡æ˜¯è¯†åˆ«ç”±äºä¸¤ä¸ªç»„ä»¶ä¹‹é—´çš„äº¤äº’è€Œäº§ç”Ÿçš„ç¼ºé™·æˆ–é—®é¢˜ï¼ŒåŒæ—¶æœ€å¤§é™åº¦åœ°å‡å°‘æ‰€éœ€çš„æµ‹è¯•ç”¨ä¾‹æ•°é‡ã€‚
2. Neighbour integration   testing only the interactions between adjacent modules that are directly connected to one another in the call graph. ä»…æµ‹è¯•åœ¨è°ƒç”¨å›¾ä¸­ç›´æ¥ç›¸äº’è¿æ¥çš„ç›¸é‚»æ¨¡å—ä¹‹é—´çš„äº¤äº’ã€‚

#### Path-based
In path-based integration testing, the system is tested for different combinations of inputs, and the resulting output paths are compared against the expected output paths. This technique aims to ensure that the system functions correctly when inputs are combined to achieve different outcomes.
åœ¨åŸºäºè·¯å¾„çš„é›†æˆæµ‹è¯•ä¸­ï¼Œæµ‹è¯•ç³»ç»Ÿçš„ä¸åŒè¾“å…¥ç»„åˆï¼Œå¹¶å°†ç”Ÿæˆçš„è¾“å‡ºè·¯å¾„ä¸é¢„æœŸçš„è¾“å‡ºè·¯å¾„è¿›è¡Œæ¯”è¾ƒã€‚è¯¥æŠ€æœ¯æ—¨åœ¨ç¡®ä¿å½“è¾“å…¥ç»„åˆä»¥å®ç°ä¸åŒçš„ç»“æœæ—¶ï¼Œç³»ç»Ÿæ­£å¸¸è¿è¡Œã€‚
#### Module Execution Path (MEP)
message method sequence of module execution paths  
![t|400x00](../img/fit5171-20230615-1.png)
![t|400x00](../img/fit5171-20230615-2.png)
## week8
### Software complexity metrics è½¯ä»¶ï¼ˆå¤æ‚åº¦ï¼‰åº¦é‡ - Structure ç»“æ„åº¦é‡
+ Control-flow structure: the sequence in which instructions are executed in a program.æ§åˆ¶æµç»“æ„ï¼šæŒ‡ä»¤åœ¨ç¨‹åºä¸­æ‰§è¡Œçš„é¡ºåºã€‚  
+ Data-flow structure: the trail of a data item created or handled by a program. æ•°æ®æµç»“æ„ï¼šä¸€ä¸ªç¨‹åºä¸­çš„æ•°æ®é¡¹ä»åˆ›å»ºåˆ°å¤„ç†çš„è½¨è¿¹ã€‚  
+ Data structure: the organization of the data itself, independent of the program. æ•°æ®ç»“æ„ï¼šæ•°æ®æœ¬èº«çš„ç»„ç»‡ï¼Œç‹¬ç«‹äºç¨‹åºã€‚
### A decomposition tree
![t|400x00](../img/fit5171-20230615-5.png)
Sequence: P1;P2 - Sequence of P1 & P2 Merge the terminal node of P1 with the initial node of P2. P1;P2 - P1 & P2 çš„åºåˆ— å°† P1 çš„ç»ˆç«¯èŠ‚ç‚¹ä¸ P2 çš„åˆå§‹èŠ‚ç‚¹åˆå¹¶  
Nesting: P1(P2 , x) - nesting of P2 onto P1 at node x Replace x with P2 ,P1(P2 , x) - åœ¨èŠ‚ç‚¹ x å¤„å°† P2 åµŒå¥—åˆ° P1 ä¸Š ç”¨ P2 æ›¿æ¢ x
![t|400x00](../img/fit5171-20230615-3.png)
![t|400x00](../img/fit5171-20230615-4.png)
![t|400x00](../img/fit5171-20230615-6.png)
### Morphology metrics
![t|400x00](../img/fit5171-20230615-7.png)
![t|400x00](../img/fit5171-20230615-8.png)
![t|400x00](../img/fit5171-20230615-9.png)
![t|400x00](../img/fit5171-20230615-10.png)
## week9
### mutation testing çªå˜/å˜å¼‚æµ‹è¯•
[Mutation operators](https://pitest.org/quickstart/mutators/)  
1. é€šè¿‡ä¸€ç³»åˆ—çš„è§„åˆ™ç”Ÿæˆæ–°çš„Java ä»£ç   ç±»ä¼¼<å˜<=; +å˜- ï¼›i++å˜i--å»æ‰call void method   Remove condition å˜ifï¼ˆtrueï¼‰  
2. ä½¿ç”¨æ–°ç”Ÿæˆçš„ä»£ç è·‘ç°æœ‰çš„Unit Testï¼Œå¦‚æœç°æœ‰çš„test methodæœ‰æ•ˆ  æ€§éå¸¸é«˜ï¼Œæ‰€æœ‰çš„testå¿…ç„¶å¤±è´¥  MTä¹‹åï¼Œtestå¤±è´¥çš„è¶Šå¤šï¼Œtest methodè¶Šå¥½   MTæ˜¯é’ˆå¯¹testçš„testï¼Œæµ‹è¯•UTæ˜¯å¦å®Œå¤‡  
3. MTç”Ÿæˆçš„ä»£ç æ˜¯æ ¹æ®Compileç”Ÿæˆçš„ä»£ç è€Œä¸æ˜¯åŸä»£ç  ï¼ˆä¸æ”¹å˜ source codeï¼‰
4. Killing the mutation  Each mutated version is called a mutant and tests detect and  reject mutants by causing the behavior of the original version to  differ from the mutant. This is called killing the mutant. ç®€è¨€ä¹‹ï¼Œmutation testä¼šåœ¨ç¨‹åºç¼–è¯‘æˆ–è¿è¡Œæ—¶æ’å…¥å¾®å°çš„å·®å¼‚(mutant)ï¼Œ ç†æƒ³çš„æµ‹è¯•ç”¨ä¾‹åº”å½“èƒ½å¤Ÿæ£€æµ‹å‡ºè¿™äº›å·®å¼‚å¸¦æ¥çš„ç¨‹åºè¡Œä¸ºå¼‚å¸¸ã€‚å¦‚æœä¸€ ä¸ªmutantå¼•å‘çš„ç¨‹åºè¡Œä¸ºå¼‚å¸¸èƒ½å¤Ÿè¢«testcasesæ•æ‰å¹¶å¯¼è‡´testcaseså¤± è´¥ï¼Œåˆ™ç§°mutantè¢«æ¶ˆç­ï¼ˆkilledï¼‰ï¼›åä¹‹å¦‚æœmutantå¸¦æ¥çš„ç¨‹åºè¡Œä¸ºå˜ åŒ–æ— æ³•è¢«æµ‹è¯•ç”¨ä¾‹æ•æ‰ï¼Œåˆ™ç§°mutantå­˜æ´»ï¼ˆsurvived/ aliveï¼‰
5. quivalent mutation a mutant cannot be killed by any set of test data. This type of mutants is said to be functionally equivalent to the originalprogramå½“æ”¹å˜ä»»ä½•æµ‹è¯•æ•°æ®ï¼Œè¿™ä¸ªtestéƒ½failä¸äº†mutationå«åšequivalent
![t|600x00](../img/fit5171-20230615-11.png)
## week11
### Finding threads- Finite State Machines
![t|400x00](../img/fit5171-20230615-12.png)
![t|400x00](../img/fit5171-20230615-13.png)
![t|400x00](../img/fit5171-20230615-14.png)
# Mock exam
## Unit Testing
### Q1
Consider a program FizzPrime that takes as input two non-negative integers, x and i, both between 0 and 100, both inclusive. The number x is a prime numbers. As output, the program prints the number i itself within the range ([0, 100]) when it is not divisible by x. For multiples of x, but not multiples of x^2, the program should print â€œFizzâ€ instead of the number. For multiples of x^2 but not multiples of x^3, the program should print â€œPrimeâ€. Finally, for numbers which are multiples of x^3 the program should print â€œFizzPrimeâ€ instead. è€ƒè™‘ä¸€ä¸ªç¨‹åº FizzPrimeï¼Œå®ƒå°†ä¸¤ä¸ªéè´Ÿæ•´æ•° x å’Œ i ä½œä¸ºè¾“å…¥ï¼Œå®ƒä»¬éƒ½åœ¨ 0 åˆ° 100 ä¹‹é—´ï¼ŒåŒ…æ‹¬ä¸¤è€…ã€‚æ•°å­— x æ˜¯è´¨æ•°ã€‚ä½œä¸ºè¾“å‡ºï¼Œç¨‹åºåœ¨ ([0, 100]) èŒƒå›´å†…æ‰“å°ä¸èƒ½è¢« x æ•´é™¤çš„æ•°å­— i æœ¬èº«ã€‚å¯¹äº x çš„å€æ•°ï¼Œä½†ä¸æ˜¯ x2 çš„å€æ•°ï¼Œç¨‹åºåº”è¯¥æ‰“å°â€œFizzâ€è€Œä¸æ˜¯æ•°å­—ã€‚å¯¹äº x2 çš„å€æ•°è€Œä¸æ˜¯ x3 çš„å€æ•°ï¼Œç¨‹åºåº”è¯¥æ‰“å°â€œPrimeâ€ã€‚æœ€åï¼Œå¯¹äº x3 çš„å€æ•°ï¼Œç¨‹åºåº”è¯¥æ‰“å°â€œFizzPrimeâ€ã€‚
####  robust equivalence classes
a) (5 marks) Develop robust equivalence classes for the input variables x and i given the  above specification. a)ï¼ˆ5 åˆ†ï¼‰æ ¹æ®ä¸Šè¿°è§„èŒƒä¸ºè¾“å…¥å˜é‡ x å’Œ i å¼€å‘ç¨³å¥çš„ç­‰ä»·ç±»  

x 
+ invalid:1. X < 0 ; X >100;  x is not a prime number  
+ valid: x >= 0 ,x<=100,x is a prime number

i  
+ invalid:1. i < 0 ;  i >100;  
+ valid: i >= 0 ,i<=100

Equivalence (i, Fizz, Prime, FizzPrime)  
	R1 = {x,i is valid, i cannot be divided by x}  
	R2 = {x,i is valid, i canbe divided by x but cannot be divided by x^2}  
	R3 = {x,i is valid, i canbe divided by x^2 but cannot be divided by x^3}  
	R4 = {x,i is valid, i canbe divided by x^3}  
	R5 = {x <0 ,i is valid} R6 = {x >100, i is valid} R7 = {X is not a prime, i is valid}  
	R8 = {i <0 ,x is valid} R9 = {i >100, x is valid}  

|test Case|x|i|Expected Output|
|---|---|---|---|
|R1|3|4|4|
|R2|3|6|Fizz|
|R3|3|9|Prime|
|R4|3|27|FizzPrime|
|R5|-1|-|Error input|
|R6|101|-|Error input|
|R7|4|-|Error input|

#### robust boundary value testing
develop test cases using the robust (not worst-case) version of the boundary value testing technique   

|Test CaseÂ |x|i|Expected OutputÂ |ExplanationÂ |
|---|---|---|---|---|
|1|-1|7|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input x is less than the lower boundary (0-100), invalid.  <br>è¾“å…¥ x å°äºä¸‹é™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|2|0|7|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input x is less than the lower boundary (0-100), invalid.  <br>è¾“å…¥ x å°äºä¸‹é™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|3|1|7|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input x is less than the lower boundary (0-100), invalid.  <br>è¾“å…¥ x å°äºä¸‹é™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|4|7|7|FizzÂ å˜¶å˜¶å£°|i is equal to x, so "Fizz" is printed.  <br>i ç­‰äº xï¼Œå› æ­¤æ‰“å°â€œå˜¶å˜¶å£°â€ã€‚|
|5|99|7|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input x is greater than the upper boundary (0-100), invalid.  <br>è¾“å…¥ x å¤§äºä¸Šé™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|6|100|7|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input x is greater than the upper boundary (0-100), invalid.  <br>è¾“å…¥ x å¤§äºä¸Šé™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|7|101|7|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input x is greater than the upper boundary (0-100), invalid.  <br>è¾“å…¥ x å¤§äºä¸Šé™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|8|7|-1|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input i is less than the lower boundary (0-100), invalid.  <br>è¾“å…¥ i å°äºä¸‹é™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|
|9|7|0|0|Number i is not divisible by x, so it remains unchanged.  <br>æ•°å­— i ä¸èƒ½è¢« x æ•´é™¤ï¼Œå› æ­¤ä¿æŒä¸å˜ã€‚|
|10|7|1|1|Number i is not divisible by x, so it remains unchanged.  <br>æ•°å­— i ä¸èƒ½è¢« x æ•´é™¤ï¼Œå› æ­¤ä¿æŒä¸å˜ã€‚|
|11|7|99|99|Number i is not divisible by x, so it remains unchanged.  <br>æ•°å­— i ä¸èƒ½è¢« x æ•´é™¤ï¼Œå› æ­¤ä¿æŒä¸å˜ã€‚|
|12|7|100|100|Number i is not divisible by x, so it remains unchanged.  <br>æ•°å­— i ä¸èƒ½è¢« x æ•´é™¤ï¼Œå› æ­¤ä¿æŒä¸å˜ã€‚|
|13|7|101|Invalid inputÂ è¾“å…¥æ— æ•ˆ|Input i is greater than the upper boundary (0-100), invalid.  <br>è¾“å…¥ i å¤§äºä¸Šé™ ï¼ˆ0-100ï¼‰ï¼Œæ— æ•ˆã€‚|

#### Blackbox testing analysis/selection
You have been given the task of performing blackbox testing on an implementation of the above algorithm. Of the main blackbox testing techniques we have discussed: boundary value testing (BVT), special value testing (SVT), equivalence class testing (ECT), and decision table-based testing (DTT), explain why each technique is(or is not) appropriate. æ‚¨çš„ä»»åŠ¡æ˜¯å¯¹ä¸Šè¿°ç®—æ³•çš„å®ç°æ‰§è¡Œé»‘ç›’æµ‹è¯•ã€‚åœ¨æˆ‘ä»¬è®¨è®ºçš„ä¸»è¦é»‘ç›’æµ‹è¯•æŠ€æœ¯ä¸­ï¼šè¾¹ç•Œå€¼æµ‹è¯• (BVT)ã€ç‰¹æ®Šå€¼æµ‹è¯• (SVT)ã€ç­‰ä»·ç±»æµ‹è¯• (ECT) å’ŒåŸºäºå†³ç­–è¡¨çš„æµ‹è¯• (DTT)ï¼Œè§£é‡Šä¸ºä»€ä¹ˆæ¯ç§æŠ€æœ¯æ˜¯ï¼ˆæˆ–ä¸æ˜¯ï¼‰ ï¼‰ åˆé€‚çš„  
+ BVT: Not a appropriate, because not consider the x is a prime and output logic.
+ SVT: is appropriate, because consider the x is a prime and output logic.
+ ECT: is appropriate
+ DTT: is appropriate, it consider the out put logic

### Q2
The minimax algorithm is a way of finding an optimal move in a two-player game for one player, by minimising the possible loss for the worst case scenario (maximum loss). It has been widely used in 2-player zero-sum game plays. The algorithm for the depth limited minimax algorithm is given below. minimax ç®—æ³•æ˜¯ä¸€ç§é€šè¿‡æœ€å°åŒ–æœ€åæƒ…å†µä¸‹çš„å¯èƒ½æŸå¤±ï¼ˆæœ€å¤§æŸå¤±ï¼‰æ¥ä¸ºä¸€ä¸ªç©å®¶åœ¨ä¸¤äººæ¸¸æˆä¸­æ‰¾åˆ°æœ€ä½³ç§»åŠ¨çš„æ–¹æ³•ã€‚å®ƒå·²å¹¿æ³›ç”¨äº 2 äººé›¶å’Œæ¸¸æˆã€‚ä¸‹é¢ç»™å‡ºæ·±åº¦å—é™æå°æå¤§ç®—æ³•çš„ç®—æ³•ã€‚
```
/*
minimax(node, depth, maximisingP layer)  
Input: node B    //Node where search begins.  
Input: depth B    //the maximum depth to search.  
Input: maximisingPlayer //Boolean value representing the player for which the search is performed.  
Output: the best value
*/
```
#### program graph
![t|300x00](../img/fit5171-20230615-16.png)
#### cyclomatic complexity of the program graph
C= E-V+2p E: è¾¹çš„æ•°é‡ N: èŠ‚ç‚¹çš„æ•°é‡ P: è¿é€šåˆ†é‡çš„æ•°é‡
Total branches (E) = 2 (for the first "if" statement) + 2 (for the second "if" statement) + N (for the "foreach" loop condition) æ€»åˆ†æ”¯ ï¼ˆEï¼‰ = 2ï¼ˆå¯¹äºç¬¬ä¸€ä¸ªâ€œifâ€è¯­å¥ï¼‰+ 2ï¼ˆå¯¹äºç¬¬äºŒä¸ªâ€œifâ€è¯­å¥ï¼‰+ Nï¼ˆå¯¹äºâ€œforeachâ€å¾ªç¯æ¡ä»¶ï¼‰
Cyclomatic Complexity = E - N + 2  = (2 + 2 + N) - N + 2 = 6
### Q3
#### program graph
![](../img/fit5171-20230616-1.png)
#### Cyclomatic complexity
draw the final condensed graph for the program graph you came up with in part (a)  above, and ii. calculate the Cyclomatic complexity of the condensed graph you draw  

### Q3
Given an undirected graph G with vertices V = {1, 2, 3, 4, 5, 6, 7, 8} and edges E = {12, 14, 16, 22, 23, 28, 34, 35, 67, 78}
#### undirected graph/directed graph
![t|400x00](../img/fit5171-20230618-3.png)  
#### node degree
Calculate the degree of each node in the graph.
![t|300x00](../img/fit5171-20230618-4.png)  

#### Cyclomatic number
The Cyclomatic number of of G, `V (G) = #E âˆ’ #V + p = 10 âˆ’ 8 + 1 = 3`  
#### source nodes or sink nodes
Source nodes: 1 Sink nodes: 4, 5, 8

#### semi-paths
Yes, (12, 23, 16, 67), (12, 28, 16, 67), and (12, 23, 34, 16, 67, 78) are semi-paths  

#### x-connected node
0-connected: none. 1-connected: 2 & 6, 3 & 7, etc. 2-connected: 1 & 2, 6 & 7, etc. 3-connected: none.  

#### reachability matrix
![t|200x00](../img/fit5171-20230618-5.png)

## Integration Testing
### Q3 select reasonable integration method 
One of the goals of integration testing is to be able to isolate faults when a test case causes a failure. Consider integration testing for a program written in a procedural/object-oriented programming language. Rate the following integration strategies on their abilities of (1) relative fault isolation and (2) testing of co-functionality. You also need to provide a rationale for your answer é›†æˆæµ‹è¯•çš„ç›®æ ‡ä¹‹ä¸€æ˜¯èƒ½å¤Ÿåœ¨æµ‹è¯•ç”¨ä¾‹å¯¼è‡´æ•…éšœæ—¶éš”ç¦»æ•…éšœã€‚è€ƒè™‘å¯¹ä½¿ç”¨é¢å‘è¿‡ç¨‹/é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ç¼–å†™çš„ç¨‹åºè¿›è¡Œé›†æˆæµ‹è¯•ã€‚è¯„ä»·ä»¥ä¸‹é›†æˆç­–ç•¥åœ¨ (1) ç›¸å¯¹æ•…éšœéš”ç¦»å’Œ (2) ååŒåŠŸèƒ½æµ‹è¯•æ–¹é¢çš„èƒ½åŠ›ã€‚æ‚¨è¿˜éœ€è¦ä¸ºæ‚¨çš„å›ç­”æä¾›ç†ç”±  
Show your ratings graphically by placing the letters corresponding to a strategy on a line, as in the example below. Suppose that for the ability of fault isolation, strategies X and Y are about equal and not very effective, and strategy Z is very effective. Note that this rating is relative and qualitative, so donâ€™t agonise over where exactly to put a  strategy, but focus on their relative position.  
A Big bang  
B Decomposition-based top-down integration  
C Decomposition-based bottom-up integration  
D Decomposition-based sandwich integration  
E Call graph-based pairwise integration  
F Call graph-based neighbourhood integration (radius 1)   
G Call graph-based neighbourhood integration (radius 2)  

the ranking of fault isolation from highest to lowest: 
A is the worst. E>F>G. Bâ‰ˆC > D 
pairwise is from two random points but Decomposition only select one unknown pts.
### Q2
![](../img/fit5171-20230618-7.png)  
####   MM-paths  
For example, the MM-path for component D (UserDAO) is MEP (D, 1) = (1, 2, 3). The MM-path for component E (MissionDAO) is MEP (E , 1) = (1, 2, 3)  
+ MEP(A,1) = (1,2,3,5)  MEP(A,2) = (1,2,4)  MEP(A,3) = (5)  
+ MEP(B,1) = (1,2,3,8)  MEP(B,2) = (1,2,4)  MEP(B,3) = (5,6,8)  MEP(B,4) = (5,7)  MEP(B,5) = (8)  
+ MEP(C,1) = (1,2)  MEP(C,2) = (3,4,8)  MEP(C,3) = (3,5,6,8)  MEP(C,4) = (3,5,7,8
#### MM-path complexity
5 edges between A and B  2 edges between B and E  4 edges between C and D  7 edges between B and C  
The Cyclomatic complexity is `V (G) = #E âˆ’ #V + p = 18 âˆ’ 5 + 1 = 14`  

## Software Metrics
### Q4
âˆƒA, B : Program â€¢ M (A) + M (B) < M (A + B)  
where M represents a given metric and A + B represents the composition of A and B  
Given a program, the repeated application of the following two operations can be used to  decompose it into a unique tree of structured programming constructs.  
Sequence: composing two program graphs sequentially by merging one program graphâ€™s  terminal node with the other program graphâ€™s initial node. For example, sequential  composition of programs A and B is denoted by A; B.  
Nesting: replacing one node in one program with the entirety of another program. For  example, nesting program B in program A at node x of A is denoted by A(B, x).  
The depth of nesting values of programs constructed by the above two operations are defined as below  
Sequence: n(P1; P2; . . . ; Pn) = max(n(P1), n(P2), . . . , n(Pn)), and  
Nesting: n(P1(P2; . . . ; Pn)) = 1 + max(n(P2), . . . , n(Pn)), where P2, . . . , Pn are sequentially  nested inside P1  
Pn sequence (n = 1, 2, . . .) D2 while loop  D0 if-then D3 do-while loop  D1 if-then-else Cn case-switch  
The depth of nesting value for all the above constructs is 1 except for P1, which is 0. The  depth of nesting value of a program is calculated in a bottom-up fashion.  
For Weyukerâ€™s property 9 and the metric depth of nesting n(P ) of a valid program P , do the  following:  
(a) State whether the property holds or not.  (b) Prove your claim (informally).
Sequence:
n(A) = n(px) ; n(B) = n(py)  
n(A+B) = n(px;py) =max(n(px),n(py)) == n(A) or n(b);  n(A+B) <= n(A) + n(b}
Nesting:  
n(A) = n(p1) = 0  ; n(B) = n(p2) = 1  
n(A+B) = n(p1(p2)) = 1 + max(n(p2)) = 2  ; n(A) + n(B) < n(A+B)

## Mutation Testing
### Q1
The following Java method, min, returns the smallest of three integer parameters  
```java
1 public int min ( int a , int b , int c ) {  
2 int temp = a ;  
3 if ( b < a ) {  
4 temp = b ;  
5 }  
6 if ( c < b ) {  
7 temp = c ;  
8 }  
9 return temp ;  
10 }
```
#### equivalent mutant
come up with an equivalent mutant by applying a first-order mutation. In your answer, identify: 1. The mutation operator applied, 2. The associated statement to be changed, and 3. What the statement is changed to.  
	Mutation Operator Applied: Relational Operator Replacement
	åº”ç”¨çš„çªå˜è¿ç®—ç¬¦ï¼šå…³ç³»è¿ç®—ç¬¦æ›¿æ¢
	This mutation operator involves changing the relational operator (e.g., >, <, = =, etc.) in a conditional statement.æ­¤çªå˜è¿ç®—ç¬¦æ¶‰åŠæ›´æ”¹æ¡ä»¶è¯­å¥ä¸­çš„å…³ç³»è¿ç®—ç¬¦ï¼ˆä¾‹å¦‚ï¼Œ > ã€ < ã€ == ç­‰ï¼‰ã€‚
	Associated Statement to be changed: Line 6 - if (c < b)è¦æ›´æ”¹çš„ç›¸å…³è¯­å¥ï¼šç¬¬ 6 è¡Œ - if (c < b)
	What the statement is changed to: We will change the < operator to <=, resulting in the modified statement: if (c <= b)è¯­å¥æ›´æ”¹ä¸ºï¼šæˆ‘ä»¬å°† < è¿ç®—ç¬¦æ›´æ”¹ä¸º <= ï¼Œå¯¼è‡´ä¿®æ”¹åçš„è¯­å¥ï¼š if (c <= b)
#### non-equivalent first-order mutants
devise a set of three test cases that achieves 100% statement coverage. Come  up with three non-equivalent first-order mutants of the original program, making use one of the following mutation operators in each mutant. Determine the kill rate of your  test suite on the three mutants.  The mutation operators you can use are:  ror Relational operator replacement.  sdl Statement deletion. uoi Unary operator insertion.   

|Test Case|Input|Expected Output|
|---|---|---|
|Case 1|a = 5, b = 3, c = 7|3|
|Case 2|a = 4, b = 6, c = 2|2|
|Case 3|a = 1, b = 2, c = 1|1|

|MutantÂ çªå˜ä½“|OperatorÂ ç®—å­|DescriptionÂ æè¿°|Original StatementÂ åŸå§‹å£°æ˜|Mutated StatementÂ çªå˜å£°æ˜|Test Case KilledÂ æµ‹è¯•ç”¨ä¾‹è¢«æ€|
|---|---|---|---|---|---|
|Mutant 1Â çªå˜ä½“ 1|ror|Relational Operator Replacement  <br>å…³ç³»è¿ç®—ç¬¦æ›¿æ¢|if (b < a)Â å¦‚æœï¼ˆb < aï¼‰|if (b >= a)Â å¦‚æœ ï¼ˆb >= aï¼‰|Case 1, Case 3Â æ¡ˆä¾‹ 1ã€æ¡ˆä¾‹ 3|
|Mutant 2Â å˜ç§äºº2|sdl|Statement DeletionÂ è¯­å¥åˆ é™¤|if (c <= b)Â å¦‚æœ ï¼ˆc <= bï¼‰|_delete lineÂ åˆ é™¤è¡Œ_|Case 1, Case 2Â æ¡ˆä¾‹ 1ã€æ¡ˆä¾‹ 2|
|Mutant 3Â å˜ç§äºº3|uoi|Unary Operator InsertionÂ ä¸€å…ƒè¿ç®—ç¬¦æ’å…¥|temp = c;Â æ¸©åº¦ = c;|temp = -c;Â æ¸©åº¦ = -c;|Case 2, Case 3Â æ¡ˆä¾‹ 2ã€æ¡ˆä¾‹ 3|

All MT be killed by test cases, so the rate is 100%
#### statement coverage
is there a defect in the program? If so, develop the smallest set of test cases that achieves 100% statement coverage but does not reveal the defect. If not, develop  the smallest set of test cases that achieves 100% statement coverage.   

defect in the program is that it doesn't compare the value of a and c. if a=1,b=3,c=2.the result will be 2 instead of 1.   

|Test CaseÂ æµ‹è¯•ç”¨ä¾‹|a|b|c|Expected OutputÂ é¢„æœŸè¾“å‡º|
|---|---|---|---|---|
|1|1|3|2|1|
|2|3|2|1|1|

# week 1 Why testing & Objectives of this unit
##   Learning Objectives:

-   explain the importance of quality assurance in software engineering;
-   articulate the role of validation and verification methods in the system development life cycle; key issues in software testing, testing levels and testing techniques
##   lecture
### Goals of Software testing  
Functionality: software functions correctly  
Usability: ease of use  
Security: free from vulnerabilities and prevent exploits  
Reliability: frequency & criticality of failures (MTBF)  
Efficiency: speed, scalability  
Maintainability: update, modify the application if required  
Portability: compatibility with other environments/systems  
### Test-driven Development (TDD)
![](../img/fit5171-20230228-2.png)
+ Test-driven development is a software development process relying on software requirements being converted to test cases before software is fully developed, and tracking all software development by repeatedly testing the software against all test cases.  
+ A Test case is a singular set of actions or instructions to perform that validates a specific aspect of a product or application functionality.

#### TDD visualised
![](../img/fit5171-20230310.png)  
1. Add a test (!)  
2. Run all tests, and confirm that the new test fails (!)  
3. Write/refine production code to cause the test to pass  
4. Run all tests again  
5. Refactor code if necessary  
6. Repeat
#### TDD: pros & cons
Advantage:  
+ More tests, less debugging  
+ More productive  
+ Validates not only code, but also  design  
+ Better test coverage, greater  confidence  
+ Better code structure

Disadvantage:  
+ difficult in certain scenarios  UI, database, network  
+ Needs management support  
+ Developer blind spots  
+ false sense of security  
+ Maintenance overhead for (bad) tests

###  black box testing
![](../img/fit5171-20230228-3.png)
### white box testing
![](../img/fit5171-20230228-4.png)
### comparison of different level of testing
![](../img/fit5171-20230228-5.png)
## tutorial 
![](../img/fit5171-20230227.png)  
```java
//pom.xml 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>io.javabrains</groupId>
    <artifactId>junit-5-basics</artifactId>
    <version>1.0-SNAPSHOT</version>

// maven properties
    <properties>
	    // level of java
        <maven.compiler.source>8</maven.compiler.source>
        // comile level of java
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        // junit.jupiter.version and the reference of junit.jupiter dependencies
        <junit.jupiter.version>5.4.0</junit.jupiter.version>
    </properties>

    <dependencies>
	    // junit-jupiter-engine core platform runing the test
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.jupiter.version}</version>
            // where to active your library
            <scope>test</scope>
        </dependency>
	    //junit-jupiter-api where you using
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.jupiter.version}</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

### 2.1 Application: anagram detector
> An anagram of a word is another word produced by rearranging the letters of the original word, using all the original letters exactly once.6 For example, â€œlistenâ€ is an anagram of â€œsilentâ€.   
> This application will need to include the following functionality.   
> 1. Given two words as input, return whether they are anagrams of each other. For example, for â€œlistenâ€ and â€œsilentâ€, the detector should return true. For â€œpizzaâ€ and â€œdonutâ€, the detector should return false.
2. Given a list of words separated by whitespace characters, return all the groups of words that are anagrams of each other. For example, assume that the detector is given the following text as input. `tews tis lives tamed elvis ream evils comics stew wets markers dashed west veils rat mace sit mated cosmic mare remarks shaded`  Given the above input, the detector will find the following groups of anagrams as output: `â€¢ tis sit
â€¢ tamed mated
â€¢ comics cosmic
â€¢ mare ream
â€¢ markers remarks
â€¢ dashed shaded
â€¢ west wets tews stew
â€¢ lives veils elvis evils
â€¢ rat
â€¢ mace`
> Note that the last two groups in the output represent the two words that do not have anagrams in the input

```java
import java.util.*;  
  
public class AnagramDetector {  
    // This is the main method of the program  
    public static void main(String[] args) {  
        // Create a scanner object to read user input from the console  
        Scanner input = new Scanner(System.in);  
        // Prompt the user to enter words separated by spaces  
        System.out.println("Enter words separated by spaces:");  
        // Read the user input as a single string  
        String words = input.nextLine();  
        // Split the string into an array of words  
        String[] wordsArray = words.split(" ");  
  
        // Call the getAnagramGroups method to group the words by anagrams  
        List<List<String>> anagramGroups = getAnagramGroups(wordsArray);  
  
        // Loop through each group of anagrams  
        for (List<String> group : anagramGroups) {  
            // Create a StringBuilder object to construct a string of words in the current group  
            StringBuilder sb = new StringBuilder();  
            // Loop through each word in the current group  
            for (String word : group) {  
                // Append the current word and a space to the StringBuilder object  
                sb.append(word).append(" ");  
            }  
            // Convert the StringBuilder object to a string and remove any extra spaces at the end  
            String result = sb.toString().trim();  
            // Print the string of words in the current group  
            System.out.println(result);  
        }  
    }  
  
    // This method takes an array of words and groups them by anagrams  
    public static List<List<String>> getAnagramGroups(String[] words) {  
        // Create a list to hold the groups of anagrams  
        List<List<String>> anagramGroups = new ArrayList<>();  
        // Create a map to hold each anagram and its corresponding group  
        Map<String, List<String>> anagramMap = new HashMap<>();  
  
        // Loop through each word in the input array  
        for (String word : words) {  
            // Convert the current word to a char array and sort it  
            char[] chars = word.toCharArray();  
            Arrays.sort(chars);  
            // Convert the sorted char array back to a string  
            String sortedWord = new String(chars);  
  
            // Check if the anagramMap already contains the current sorted word  
            if (anagramMap.containsKey(sortedWord)) {  
                // If it does, add the current word to the corresponding group  
                anagramMap.get(sortedWord).add(word);  
            } else {  
                // If it doesn't, create a new group for the current word  
                List<String> group = new ArrayList<>();  
                group.add(word);  
                // Add the new group to the anagramGroups list  
                anagramGroups.add(group);  
                // Add the current sorted word and its corresponding group to the anagramMap  
                anagramMap.put(sortedWord, group);  
            }  
        }  
  
        // Return the list of groups of anagrams  
        return anagramGroups;  
    }  
}
```
### TDD(Test-Driven Development) for 2.1
> Making use of the TDD process, write some tests for the above functionality and use them to guide you in writing the actual code that actually implements the functionality. You should do this iteratively
####  Iteration 1 
```java
@Test  
 /*  
check that the getAnagramGroups method returns an  
empty list when passed an empty array of words.  
*/  
void getAnagramGroupsEmptyList() {  
    String[] words = {};  
    List<List<String>> result = AnagramDetector.getAnagramGroups(words);  
    assertTrue(result.isEmpty());  
}
```
it return true so no need to modify
#### Iteration 2
```java
@Test  
    /*  
    * check that the getAnagramGroups method correctly groups    * a set of words that are all anagrams of each other    * */void getAnagramGroupsSameGroup() {  
    String[] words = {"listen", "silent", "enlist"};  
    List<List<String>> result = AnagramDetector.getAnagramGroups(words);  
    assertEquals(1, result.size());  
    assertTrue(result.get(0).contains("listen"));  
    assertTrue(result.get(0).contains("silent"));  
    assertTrue(result.get(0).contains("enlist"));  
}
```
it return true so no need to modify
####  Iteration 3
```java 
@Test  
public void testGetAnagramGroups() {  
    // Test case with no input  
    String[] emptyWordsArray = {};  
    assertTrue(AnagramDetector.getAnagramGroups(emptyWordsArray).isEmpty());  
  
    // Test case with single word input  
    String[] singleWordArray = {"hello"};  
    assertEquals(1, AnagramDetector.getAnagramGroups(singleWordArray).size());  
  
    // Test case with input containing only anagrams  
    String[] anagramWordsArray = {"race", "care", "acre"};  
    assertEquals(1, AnagramDetector.getAnagramGroups(anagramWordsArray).size());  
  
    // Test case with input containing no anagrams  
    String[] nonAnagramWordsArray = {"hello", "world", "java"};  
    assertEquals(3, AnagramDetector.getAnagramGroups(nonAnagramWordsArray).size());  
  
    // Test case with input containing multiple anagram groups  
    String[] multipleGroupsWordsArray = {"race", "care", "acre", "listen", "silent", "enlist"};  
    assertEquals(2, AnagramDetector.getAnagramGroups(multipleGroupsWordsArray).size());  
  
    
}
```
it all return true so no need to modify
#### Iteration 4
```java
@Test  
/*  
* This test case ensures that the getAnagramGroups method correctly  
* groups anagrams even when the input array contains duplicates  
* */  
public void testGetAnagramGroups_InputWithDuplicates_ReturnsAnagramGroups() {  
    AnagramDetector detector = new AnagramDetector();  
    List<List<String>> result = detector.getAnagramGroups(new String[]{"eat", "tea", "ate", "ape", "pea", "pea", "are"});  
    assertEquals(3, result.size());  
    assertTrue(result.contains(Arrays.asList("eat", "tea", "ate")));  
    assertTrue(result.contains(Arrays.asList("ape", "pea", "pea")));  
    assertTrue(result.contains(Collections.singletonList("are")));  
    assertFalse(result.contains(Arrays.asList("tea", "ate", "eat", "pea", "ape", "pea", "are")));  
}
```

### 2.2 k-th largest element of an array
>  write  a java program k-th largest element of an array user input an array sperate by , first and then input an int k, find the k-th largest element in this array.   
>  IF given an array -1, 0, 2, 6, 4 and  3, you are required to find the 3rd largest element of the array, which is 2
```java
import java.util.Arrays;  
import java.util.Scanner;  
  
public class KthLargestElement {  
  
    public static void main(String[] args) {  
        // Read input array from user  
        Scanner scanner = new Scanner(System.in);  
        System.out.print("Enter the array elements separated by comma: ");  
        String input = scanner.nextLine();  
        String[] values = input.split(",");  
        int[] arr = new int[values.length];  
        for (int i = 0; i < values.length; i++) {  
            arr[i] = Integer.parseInt(values[i].trim());  
        }  
  
        // Read the value of k from user  
        System.out.print("Enter the value of k: ");  
        int k = scanner.nextInt();  
  
        // Find the k-th largest element using findKthLargestElement()  
        int kthLargest = findKthLargestElement(arr, k);  
  
        // Print the k-th largest element  
        System.out.println("The " + k + "-th largest element is " + kthLargest);  
    }  
  
    public static int findKthLargestElement(int[] arr, int k) {  
      
	// If k is greater than the length of the array, return -1  
	if (k > arr.length) {  
	    return -1;  
	}  
	  
	// Sort the array in descending order  
	Arrays.sort(arr);  
	int x = arr.length - k;  
	int kthLargest = arr[x];  
	return kthLargest;
	}
}

```
terminal window  
```
Enter the array elements separated by comma: -1, 0, 2, 6, 4
Enter the value of k: 3
The 3-th largest element is 2

```

so we will test findKthLargestElement() method and make iteration
```java 
public static int findKthLargestElement(int[] arr, int k) {  
      
	// If k is greater than the length of the array, return -1  
	if (k > arr.length) {  
	    return -1;  
	}  
	  
	// Sort the array in descending order  
	Arrays.sort(arr);  
	int x = arr.length - k;  
	int kthLargest = arr[x];  
	return kthLargest;
}
```
#### Iteration 1: Simple Test Case
```java
@Test  
/*  
* an array with only one element, and we want to  
* find the 1st largest element. We expect the output to be the same element.  
* */  
public void testKthLargestElement() {  
    int[] arr = {3};  
    int k = 1;  
    int expected = 3;  
    int actual = KthLargestElement.findKthLargestElement(arr, k);  
    assertEquals(expected, actual);  
}  
  
@Test  
/*  
*  array of multiple elements. We want to find the 3rd largest element of the array.  
* */  
public void testKthLargestElementMulti() {  
    // Test Case 1  
    int[] arr1 = {3};  
    int k1 = 1;  
    int expected1 = 3;  
    int actual1 = KthLargestElement.findKthLargestElement(arr1, k1);  
    assertEquals(expected1, actual1);  
  
    // Test Case 2  
    int[] arr2 = {5, 3, 9, 8, 1};  
    int k2 = 3;  
    int expected2 = 5;  
    int actual2 = KthLargestElement.findKthLargestElement(arr2, k2);  
    assertEquals(expected2, actual2);  
}
```

#### Iteration : Edge Cases
```java
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class KthLargestElementTest {

    @Test
    public void testKthLargestElement() {
        // Test Case 1
        int[] arr1 = {3};
        int k1 = 1;
        int expected1 = 3;
        int actual1 = KthLargestElement.findKthLargestElement(arr1, k1);
        assertEquals(expected1, actual1);

        // Test Case 2
        int[] arr2 = {5, 3, 9, 8, 1};
        int k2 = 3;
        int expected2 = 5;
        int actual2 = KthLargestElement.findKthLargestElement(arr2, k2);
        assertEquals(expected2, actual2);

        // Test Case 3
        int[] arr3 = {3, 3, 5, 2, 5, 2};
        int k3 = 2;
        int expected3 = 5;
        int actual3 = KthLargestElement.findKthLargestElement(arr3, k3);
        assertEquals(expected3, actual3);

        // Test Case 4
        int[] arr4 = {5, 3, 9, 8, 1};
        int k4 = 10;
        int expected4 = -1;
        int actual4 = KthLargestElement.findKthLargestElement(arr4, k4);
        assertEquals(expected4, actual4);

        // Test Case 5
        int[] arr5 = {};
        int k5 = 1;
        int expected5 = -1;
        int actual5 = KthLargestElement.findKthLargestElement(arr5, k5);
        assertEquals(expected5, actual5);
    }
}

```
all pass

# Week 2 Test-driven Development/ Unit testing / Test Planning
## Learning Objectives
-   articulate the advantages and disadvantages of <mark style="background: #0000CD;">Test-Driven Development (TDD)</mark>  
-   know the benefits of unit testing; develop unit test cases using industry-strength IDES, and unit testing frameworks such as JUnit.Â   
-   demonstrate the basic elements of <mark style="background: #ff0000;">test strategy and test planning</mark>;
## Lecture
### Unit testing
Unit: a very small abstraction of a class/object that performs some operations  
Unit testing: testing units  Individually, in isolation, separately, not together, one at a time  
#### Junit basics
+ JUnit tests are also called test methods in a test class
+ Naming convention of test classes: name of class under  test + Test `ShoppingCartTest.java for  ShoppingCart.java`  
+ Test names should be meaningful and reflect purpose `shouldReturnTrueWhenUsersHaveSameEmail()`
#### Test Annotations
[JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations)  
`@Before Each, @After Each` :  
initialise the user every time before  running the test case for a particular user  
```java
private User target;  
@BeforeEach  
public void setUp() {  
	target = new User();  
}
```
`@Timeout(value=1000, unit =  TimeUnit.MILLISECONDS)` : timeout  
in 1,000 milliseconds  
`@ParameterisedTest` : Claim this  
methods has input parameter  
```java
@ParameterizedTest 
@ValueSource(ints = {1, 3, 5, -3, 15, Integer.MAX_VALUE}) // six numbers 
void isOdd_ShouldReturnTrueForOddNumbers(int number) { 
	assertTrue(Numbers.isOdd(number)); 
}
```
#### Test Assertions
Assertions allow us to compare  expected vs actual behaviours (output  values, exceptions, etc.)  
```java
assertTrue() assertFalse()  
assertEquals() assertNotEquals()  
assertNull() assertNotNull()  
assertSame() assertNotSame()  
assertArrayEquals() assertThrows()  
```

### Test plan
[Sample System Integration Test Plan - XYZ Remote Office Payroll System ](https://www.practitest.com/assets/pdf/system-integration-testing-template.pdf)

## Tutorial
You will create  add method for each requirement incrementally. You will be develop the requirements using TDD.
### Quiz
![](../img/fit5171-20230310-1.png)
![](../img/fit5171-20230310-2.png)
### Iteration 1
The method can take up to 2 numbers, and will return their sum (for an empty string it will return 0)  for example â€œâ€ or â€œ1â€ or â€œ1,2â€ 
```java
@Test
public void testAddMethodWithEmptyString() {
    StringCalculator calculator = new StringCalculator();
    int result = calculator.add("");
    assertEquals(0, result);
}

```  

```java
public class StringCalculator {
    public int add(String numbers) {
        if (numbers.isEmpty()) {
            return 0;
        }
        return -1; // Placeholder return value for now
    }
}
```
### iteration 2
the method now can take any amount of numbers
```java
@Test
public void testAddMethodWithMultipleNumbers() {
    StringCalculator calculator = new StringCalculator();
    int result = calculator.add("1,2,3,4,5");
    assertEquals(15, result);
}
```  

```java
// Calculate the sum of the numbers  
int sum = 0;  
for (String token : tokens) {  
    // Convert each token to an integer and add it to the sum  
    sum += Integer.parseInt(token);  
}

```
### iteration 3
allow the Add method to handle new lines between numbers (instead of commas). The following input is ok: â€œ1\n2,3â€ (will equal 6)  
```java
@Test
public void testAddMethodWithNewLinesBetweenNumbers() {
    StringCalculator calculator = new StringCalculator();
    int result = calculator.add("1\n2,3");
    assertEquals(6, result);
}

```

```java
String[] tokens = numbers.split("[,\n]");
```
### iteration 4
```java
/*  
* Support different delimiters, the beginning of the string  
* will contain a separate line that looks like this:â€œ//delimiter\n[numbers. . . ]â€  
* for example â€œ//;\n1;2â€ should return three where the delimiter is â€˜;â€™  
* item The first line is optional. All existing scenarios should still be supported  
* */  
@Test  
public void testAddMethodWithCustomDelimiter() {  
    StringCalculator calculator = new StringCalculator();  
    int result = calculator.add("//;\n1;2");  
    assertEquals(3, result);  
}
```  
split the input string `numbers` using a regular expression that matches either commas or new lines as a delimiter, using the pattern `[,\n]`. This allows  handle both commas and new lines as separators between the numbers
```java
// Default delimiter is comma or new line 
String delimiter = "[,\n]"; 
// Check if the input string specifies a custom delimiter 
if (numbers.startsWith("//")) { 
// Extract the delimiter and the numbers 
	int delimiterEndIndex = numbers.indexOf("\n"); 
	delimiter = numbers.substring(2, delimiterEndIndex); 
	numbers = numbers.substring(delimiterEndIndex + 1); 
} 
// Split the input string using the specified delimiter 
String[] tokens = numbers.split(delimiter); 
// Calculate the sum of the numbers 
int sum = 0;
```

### Iteration 5
```java
/*  
* Calling add with a negative number will throw an exception  
* â€œnegatives not allowedâ€ â€“ and prints the negative number that was passed.  
* If there are multiple negatives, show all of them in the exception message  
* */  
@Test  
public void testAddMethodWithNegativeNumbers() {  
    StringCalculator calculator = new StringCalculator();  
    try {  
        int result = calculator.add("1,-2,3,-4");  
        fail("Exception should have been thrown");  
    } catch (IllegalArgumentException e) {  
        assertEquals("Negatives not allowed: -2, -4", e.getMessage());  
    }  
}
```  

```java
// Calculate the sum of the numbers  
int sum = 0;  
List<Integer> negatives = new ArrayList<>();  
for (String token : tokens) {  
    // Convert each token to an integer and add it to the sum  
    int number = Integer.parseInt(token);  
    if (number < 0) {  
        negatives.add(number);  
    }  
    sum += number;  
}  
  
// If there are negative numbers, throw an exception  
if (!negatives.isEmpty()) {  
    StringBuilder sb = new StringBuilder("Negatives not allowed: ");  
    for (int i = 0; i < negatives.size(); i++) {  
        sb.append(negatives.get(i));  
        if (i < negatives.size() - 1) {  
            sb.append(", ");  
        }  
    }  
    throw new IllegalArgumentException(sb.toString());  
}
```

### iteration 6
```java
/*  
* Numbers bigger than 1000 should be ignored, so adding 2 + 1001 = 2  
* */  
@Test  
public void testAddMethodWithNumbersGreaterThan1000() {  
    StringCalculator calculator = new StringCalculator();  
    int result = calculator.add("2,1000,1001");  
    assertEquals(1002, result);  
}
```

```java
// Calculate the sum of the numbers, ignoring numbers greater than or equal to 1000 
int sum = 0; 
List<Integer> negatives = new ArrayList<>(); 
for (String token : tokens) { 
	// Convert each token to an integer and add it to the sum 
	int number = Integer.parseInt(token); 
	if (number < 0) { 
		negatives.add(number); 
	} 
	else if (number <= 1000) { 
		sum += number; 
	} 
}
```

### Iteration 7
```java
/*  
* Delimiters can be of any length with the following format:  
* â€œ//[delimiter]\nâ€ for example: â€œ//[â€”]\n1â€”2â€”3â€ should return 6  
* */  
@Test  
public void testAddMethodWithLongDelimiter() {  
    StringCalculator calculator = new StringCalculator();  
    int result = calculator.add("//[***]\n1***2***3");  
    assertEquals(6, result);  
}
```

handle long delimiters by checking if the delimiter starts and ends with square brackets, and removing them if so. Also use the `Pattern.quote` method to escape any special characters in the delimiter before using it to split the input string.
```java
// Check if the input string specifies a custom delimiter  
if (numbers.startsWith("//")) {  
    // Extract the delimiter and the numbers  
    int delimiterEndIndex = numbers.indexOf("\n");  
    delimiter = numbers.substring(2, delimiterEndIndex);  
    // Handle long delimiters  
    if (delimiter.startsWith("[") && delimiter.endsWith("]")) {  
        delimiter = delimiter.substring(1, delimiter.length() - 1);  
    }  
    numbers = numbers.substring(delimiterEndIndex + 1);  
}  
  
// Split the input string using the specified delimiter  
String[] tokens = numbers.split(Pattern.quote(delimiter));
```
### iteration 8 
```java
/*  
* Allow multiple delimiters like this: â€œ//[delimitor1][delimitor2]\nâ€  
* for example â€œ//[-][;]\n1-2;3â€ should return 6  
* */  
@Test  
public void testAddMethodWithMultipleDelimiters() {  
    StringCalculator calculator = new StringCalculator();  
    int result = calculator.add("//[-][;]\n1-2;3");  
    assertEquals(6, result);  
}
```  
update the `add` method to handle this case by modifying the regular expression used to split the input string. extract the delimiter(s) from the input string and use the `|` character to indicate alternate delimiters in the regular expression used to split the input string. The delimiter(s) can be specified in the input string using the format `//[delimiter]\n` (for a single delimiter) or `//[delimiter1][delimiter2]...\n` (for multiple delimiters).
```java
// Check if the input string has a custom delimiter  
String delimiterRegex = "[,\n]";  
if (numbers.startsWith("//")) {  
    int delimiterStartIndex = 2;  
    int delimiterEndIndex = numbers.indexOf("\n");  
    String delimiterLine = numbers.substring(delimiterStartIndex, delimiterEndIndex);  
    // Split the delimiter line by "][" to handle multiple delimiters  
    String[] delimiters = delimiterLine.split("\\]\\[");  
    for (String delimiter : delimiters) {  
        // Remove the square brackets from each delimiter  
        delimiter = delimiter.replace("[", "").replace("]", "");  
        // Add each delimiter to the regular expression  
        delimiterRegex += "|" + Pattern.quote(delimiter);  
    }  
    // Remove the delimiter line from the input string  
    numbers = numbers.substring(delimiterEndIndex + 1);  
}  
  
// Split the input string using the delimiter(s)  
String[] tokens = numbers.split(delimiterRegex);
```

### Iteration 9 IDK 
```java
/*  
* Make sure you can also handle multiple delimiters with  
* length longer than one char  
* */  
@Test  
public void Q9AddMultipleDelimiters() {  
    StringCalculator calculator = new StringCalculator();  
    int result = calculator.add("//[---][%$]\n1--;2$3");  
    assertEquals(6, result);  
}
```

# Week 3 Discrete maths
## Lecture
[Glossary of mathematical symbols - Wikipedia](https://en.wikipedia.org/wiki/Glossary_of_mathematical_symbols)  
[Directed and Undirected graph in Discrete Mathematics](https://www.javatpoint.com/directed-and-undirected-graph-in-discrete-mathematics)  
[CS Academy graph generater](https://csacademy.com/app/graph_editor/)  
Logic  
Basic set theory  
Relations & functions  
Basic graph theory  
### Quiz
![](../img/fit5171-20230316-1.png)  
![](../img/fit5171-20230316-3.png)
### Propositional logic å‘½é¢˜é€»è¾‘
Propositional logic is the logic that deals with a collection of declarative statements which have a truth value,  <mark style="background: #0000CD;">true or false</mark>.  
Proposition symbols:  `penguines_black_white`  
logical operators : Logic not (Â¬), and (â‹€), or (â‹), impliesæ„å‘³ç€  (â‡’) & equivalent (â‡”)  
å…¬ç†å’Œæ¨ç†è§„åˆ™ `Â¬ Â¬pâŠ¢p, {p, p â‡’q}âŠ¢q`  
![](../img/fit5171-20230313.png)

Predicate logic is an expression consisting of variables with a specified domain. It consists of objects, relations,  formulas and/or functions between the objects è°“è¯é€»è¾‘æ˜¯ç”±å…·æœ‰æŒ‡å®šåŸŸçš„å˜é‡ç»„æˆçš„è¡¨è¾¾å¼ã€‚å®ƒç”±å¯¹è±¡ã€å¯¹è±¡ä¹‹é—´çš„å…³ç³»ã€å…¬å¼å’Œ/æˆ–å‡½æ•°ç»„æˆ
+ Universal (âˆ€) & existential (âˆƒ)  
+ âˆ€x . P(x) => âˆ€ logician . wants_beer(logician)  

#### First-order logic  
+ Quantifies over arguments only  
+ Exist a person who is both a student and a tutor in  FIT.  
+ âˆƒx (P(x) â‹€ Q(x)

### Basic set definitions
Definition: a collection of elements  No ordering, no multiplicity å®šä¹‰ï¼šå…ƒç´ çš„é›†åˆæ²¡æœ‰é¡ºåºï¼Œæ²¡æœ‰å¤šé‡æ€§
+ Enumeration: {1,2,3,4}  
+ Set comprehension: ${x : N | x â‰¤ 64}$  
+ A special set - the empty set âˆ…  

### Set membership & inclusion
+ Membership: $xâˆˆ{x}, x âˆ‰ âˆ…$
+ Subsetå­é›†ï¼š: $A âŠ† B â‡” âˆ€ x : A â€¢ x âˆˆ B$
+ Proper subset ![](../img/fit5171-20230313-2.png)
+ Set cardinality è®¾ç½®åŸºæ•° `#A | A |` `#A = 3`

#### Power set P
A power set is set of all subsets, empty set and the original set itself å¹‚é›†æ˜¯æ‰€æœ‰å­é›†ã€ç©ºé›†å’ŒåŸå§‹é›†æœ¬èº«çš„é›†åˆ   
+ $âˆ€X â€¢ X$   is a set, $Px = {A|A âŠ† X}$  
+ power set of A = {1, 2} is P(A) = {{}, {1}, {2}, {1, 2}}
#### Set operations
![](../img/fit5171-20230313-3.png)
+ Union : $A ğ•Œ B$  The set containing all the elements of  which all other sets are subs
+ Intersection : $Aâˆ©B$  Items common in A,B
+ Difference : $A\B$ 
+ Cartesian productç¬›å¡å°”ç§¯ : `{a, b} X {0, 1} = {(a, 0), (a, 1), (b, 0), (b, 1)}`
### Relations ( â‡”) & functions (â†’ )  
#### Relations ( â‡”)
Relations (R) are defined over sets  A relation is a collection of ordered pairs, which  contains an object from one set to the other set å…³ç³» (R) æ˜¯åœ¨é›†åˆä¸Šå®šä¹‰çš„ å…³ç³»æ˜¯æœ‰åºå¯¹çš„é›†åˆï¼Œå…¶ä¸­åŒ…å«ä»ä¸€ä¸ªé›†åˆåˆ°å¦ä¸€ä¸ªé›†åˆçš„å¯¹è±¡ Can be one-to-one, one-to-many  or many-to-one, many-to-many  
The Cartesian product deals with ordered pairs, so  the order in which the sets are considered is ç¬›å¡å°”ç§¯å¤„ç†æœ‰åºå¯¹ï¼Œå› æ­¤è€ƒè™‘é›†åˆçš„é¡ºåºæ˜¯  `friends : Person â‡” Person`  
$X Ñ… Y = {(x, y)} | x âˆˆ X and y âˆˆ Y} Where X Ñ… Y â‰  Y Ñ… X$  
Using n(A) for the number of elements in a set A, we have $n(X Ñ… Y) = n(X) Ñ… n(Y)$ 
#### functions (â†’ )
It is a relation that defines the set of  inputs to the set of outputs.  Note that all functions are relations, but  not all relations are functions å®ƒæ˜¯å®šä¹‰è¾“å…¥é›†åˆ°è¾“å‡ºé›†çš„å…³ç³»ã€‚è¯·æ³¨æ„ï¼Œæ‰€æœ‰å‡½æ•°éƒ½æ˜¯å…³ç³»ï¼Œä½†å¹¶éæ‰€æœ‰å…³ç³»éƒ½æ˜¯å‡½æ•°  
`â†’ `  implies/ when used in functions, it  symbolises mapping Aâ†’B, if A is true then B is also true.  If A is false then nothing said about  B  
`age : Person N`  `birthday : Person â†’ Date`  
### Graph theory
#### Undirected graphs æ— å‘å›¾  
[CS Academy graph generater](https://csacademy.com/app/graph_editor/)
![](../img/fit5171-20230313-4.png)
$G = (V, E)$   
+ <mark style="background: #ff0000;">V: a non-empty set of nodes {n1, n2 , n3, ..., nm }</mark>    
+ <mark style="background: #ff0000;">E: a set of edges {e1, e2, ..., ep}, where each ek = (ni, nj)</mark>  
#### Representation & Degree
![](../img/fit5171-20230313-5.png)
`V = {n 1 , n 2 , n 3 , n 4 , n 5 , n 6 , n 7}`  
`E = {e1 , e2 , e3 , e4 , e 5 , } = {(n 1 , n 2 ), (n 1 , n 4 ), (n 2 , n 5 ), (n 3 , n 4 ), (n 4 , n 6 )}`  
<mark style="background: #0000CD;">Degree of node : No. of edges that have that node as  an endpoint</mark>  
`degree(n 1 ) = 2, degree(n 4 ) = 3,  degree(n 7 ) = 0`  
#### Incidence Matrix
![](../img/fit5171-20230314-1.png)
#### Path & Connectedness
Nodes ni and nj are connected if they  are in a path.  A component is a maximal set of  connected node å¦‚æœèŠ‚ç‚¹ ni å’Œ nj åœ¨ä¸€æ¡è·¯å¾„ä¸­ï¼Œåˆ™å®ƒä»¬æ˜¯è¿é€šçš„ åˆ†é‡æ˜¯è¿é€šèŠ‚ç‚¹çš„æœ€å¤§é›†åˆ `Path(n1,n5) = (n1, n2, n5) = <e1,  e4>` 
![](../img/fit5171-20230314-5.png)
### Directed graphs
![](../img/fit5171-20230314-6.png)
directed graph D = (V, E)  
+ V: a non-empty set of nodes {n1,  n2, n3 , ..., n m } 
+ E: a set of edges {e1, e2, ..., ep}  
where each ek = <ni, nj> an ordered pair
#### Indegrees & outdegrees
![](../img/fit5171-20230314-7.png)
+ Indegree (or fan-in) of a node n is  the<mark style="background: #0000CD;"> no. of distinct edges that have n as  target</mark>. A node with indegree = 0 is called a source node  
+ Outdegree (or fan-out) of a node n  is the<mark style="background: #ff0000;"> no. of distinct edges that have n  as the start node</mark>.  A node with outdegree = 0 is called a  sink node
#### Paths & semi-paths
![](../img/fit5171-20230314-8.png)

## Tutorial
### Q1
Decide if the following predicates are true. If not, give a counter example   
#### (a) âˆ€AâˆƒB â€¢ C â‰¡ âˆƒBâˆ€A â€¢ C , where A and B are variable declarations and C is a Boolean expression  
1. check if both sides of the equivalence are logically equivalent  
2. âˆ€AâˆƒB â€¢ C = "For all A, there exists a B such that C is true"  âˆ€AâˆƒB â€¢ C =â€œå¯¹äºæ‰€æœ‰Aï¼Œå­˜åœ¨ä¸€ä¸ªBä½¿å¾—Cä¸ºçœŸâ€
3. âˆƒBâˆ€A â€¢ C = "There exists a B such that for all A, C is true"  âˆƒBâˆ€A â€¢ C =â€œå­˜åœ¨ä¸€ä¸ªBä½¿å¾—å¯¹äºæ‰€æœ‰Aï¼ŒCä¸ºçœŸâ€
4. find a counterexample  A be the set of integers and B be the set of real numbers. Let C be the Boolean expression "A is a subset of B".
5. âˆ€AâˆƒB â€¢ C = "For all sets of integers A, there exists a set of real numbers B such that A is a subset of B" âˆ€AâˆƒB â€¢ C = â€œå¯¹äºæ‰€æœ‰æ•´æ•°é›† Aï¼Œå­˜åœ¨ä¸€ç»„å®æ•° Bï¼Œä½¿å¾— A æ˜¯ B çš„å­é›†â€This statement is true because we can always choose B to be the set of real numbers, which contains the set of integers. Therefore, C is true for all A.
6. âˆƒBâˆ€A â€¢ C = "There exists a set of real numbers B such that for all sets of integers A, A is a subset of B" âˆƒBâˆ€A â€¢ C = â€œå­˜åœ¨ä¸€ç»„å®æ•° Bï¼Œä½¿å¾—å¯¹äºæ‰€æœ‰æ•´æ•°é›† Aï¼ŒA æ˜¯ B çš„å­é›†â€ 
7. This statement is false because we can choose B to be any non-empty set of real numbers, and there will always exist an integer that is not in B. Therefore, C is false for some A. è¿™ä¸ªé™ˆè¿°æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥é€‰æ‹© B æ˜¯ä»»ä½•éç©ºçš„å®æ•°é›†ï¼Œå¹¶ä¸”æ€»ä¼šå­˜åœ¨ä¸€ä¸ªä¸åœ¨ B ä¸­çš„æ•´æ•°ã€‚å› æ­¤ï¼Œå¯¹äºæŸäº› Aï¼ŒC æ˜¯é”™è¯¯çš„ã€‚
8. conclusion:  âˆ€AâˆƒB â€¢ C is not logically equivalent to âˆƒBâˆ€A â€¢ C
#### (b) âˆ€A, B : P N â€¢ A âŠ† B âˆ¨ B âŠ† A 
âˆ€A, B : P N â€¢ A âŠ† B âˆ¨ B âŠ† A can be read as "For all sets A and B of natural numbers, A is a subset of B or B is a subset of A." âˆ€A, B : P N â€¢ A âŠ† B âˆ¨ B âŠ† A å¯ä»¥ç†è§£ä¸ºâ€œå¯¹äºè‡ªç„¶æ•°çš„æ‰€æœ‰é›†åˆ A å’Œ Bï¼ŒA æ˜¯ B çš„å­é›†æˆ– B æ˜¯ A çš„å­é›†ã€‚â€To prove this predicate, we need to show that for any arbitrary sets A and B of natural numbers, either A is a subset of B or B is a subset of A. ä¸ºäº†è¯æ˜è¿™ä¸ªè°“è¯ï¼Œæˆ‘ä»¬éœ€è¦è¯æ˜å¯¹äºä»»æ„è‡ªç„¶æ•°é›†åˆ A å’Œ Bï¼Œè¦ä¹ˆ A æ˜¯ B çš„å­é›†ï¼Œè¦ä¹ˆ B æ˜¯ A çš„å­é›†ã€‚
1. Case 1: A âŠ† B If A is a subset of B, then the predicate is true.  
2. Case 2: B âŠ† A If B is a subset of A, then the predicate is true.
3. Case 3: A âˆ© B = âˆ… If A and B have no common elements, then either A is a subset of B or B is a subset of A. This is because if there is no element in common between A and B, then either A is entirely contained within B, or B is entirely contained within A. å¦‚æœ A å’Œ B æ²¡æœ‰å…¬å…±å…ƒç´ ï¼Œåˆ™ A æ˜¯ B çš„å­é›†æˆ– B æ˜¯ A çš„å­é›†ã€‚è¿™æ˜¯å› ä¸ºå¦‚æœ A å’Œ B ä¹‹é—´æ²¡æœ‰å…¬å…±å…ƒç´ ï¼Œåˆ™ A å®Œå…¨åŒ…å«åœ¨ B ä¸­ï¼Œæˆ–è€…B å®Œå…¨åŒ…å«åœ¨ A ä¸­ã€‚
4. Case 4: A âˆ© B â‰  âˆ… If A and B have some common elements, then we can define the set C = A âˆª B. Since C is a set of natural numbers, we know that C is a subset of the natural numbers å¦‚æœAå’ŒBæœ‰ä¸€äº›å…±åŒçš„å…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å®šä¹‰é›†åˆC = A âˆª Bã€‚ç”±äºCæ˜¯è‡ªç„¶æ•°çš„é›†åˆï¼Œæˆ‘ä»¬çŸ¥é“Cæ˜¯è‡ªç„¶æ•°çš„å­é›† Moreover, we know that A and B are not disjoint, so A âˆ© B â‰  âˆ… implies that A and B are not both equal to âˆ…. æ­¤å¤–ï¼Œæˆ‘ä»¬çŸ¥é“ A å’Œ B ä¸ç›¸äº¤ï¼Œæ‰€ä»¥ A âˆ© B â‰  âˆ… æ„å‘³ç€ A å’Œ B ä¸éƒ½ç­‰äº âˆ…ã€‚A and B are not both equal to âˆ…. Therefore, at least one of A and B is not equal to âˆ…, which implies that at least one of A and B is not equal to âˆ… âˆª âˆ… = âˆ…. A å’Œ B ä¸éƒ½ç­‰äº âˆ…ã€‚å› æ­¤ï¼ŒA å’Œ B ä¸­è‡³å°‘æœ‰ä¸€ä¸ªä¸ç­‰äº âˆ…ï¼Œè¿™æ„å‘³ç€ A å’Œ B ä¸­è‡³å°‘æœ‰ä¸€ä¸ªä¸ç­‰äº âˆ… âˆª âˆ… = âˆ…ã€‚
5. for any arbitrary sets A and B of natural numbers, either A is a subset of B or B is a subset of A. Therefore, the predicate âˆ€A, B : P N â€¢ A âŠ† B âˆ¨ B âŠ† A is true. å¯¹äºä»»æ„è‡ªç„¶æ•°é›†åˆ A å’Œ Bï¼Œè¦ä¹ˆ A æ˜¯ B çš„å­é›†ï¼Œè¦ä¹ˆ B æ˜¯ A çš„å­é›†ã€‚å› æ­¤ï¼Œè°“è¯âˆ€A, B : P N â€¢ A âŠ† B âˆ¨ B âŠ† A ä¸ºçœŸã€‚
### Q2
Give a formal definition of the binary relation R, over natural numbers, such that each x is related to y  by R if and only if y is greater than the square of x but less than the square of x + 1. ç»™å‡ºè‡ªç„¶æ•°ä¸ŠäºŒå…ƒå…³ç³» R çš„æ­£å¼å®šä¹‰ï¼Œä½¿å¾—æ¯ä¸ª x éƒ½é€šè¿‡ R ä¸ y ç›¸å…³å½“ä¸”ä»…å½“ y å¤§äº x çš„å¹³æ–¹ä½†å°äº x + 1 çš„å¹³æ–¹ã€‚For any x, y âˆˆ N, xRy if and only if y > x^2 and y < (x+1)^2.  
1. simply plug in the values of x and y into the definition of the relation and see if it holds true x=2 and y=9, 9 > 2^2 and 9 < (2+1)^2 True  
2. x=3 and y=8, 8 > 3^2 and 8 < (3+1)^2 False
### Q3
Let S be the set of natural numbers between 1 and 15 inclusively. Express R in Q2 as a set of ordered pairs in S.   è®¾ S ä¸º 1 åˆ° 15 ä¹‹é—´çš„è‡ªç„¶æ•°é›†ã€‚å°† Q2 ä¸­çš„ R è¡¨ç¤ºä¸º S ä¸­çš„ä¸€ç»„æœ‰åºå¯¹ã€‚For any x, y âˆˆ N, xRy if and only if y > x^2 and y < (x+1)^2.  R as a set of ordered pairs in S, where S is the set of natural numbers between 1 and 15 inclusively. To do this, we need to list all the pairs (x, y) where x and y are elements of S and xRy holds. R ä½œä¸º S ä¸­çš„ä¸€ç»„æœ‰åºå¯¹ï¼Œå…¶ä¸­ S æ˜¯ 1 åˆ° 15 ä¹‹é—´çš„è‡ªç„¶æ•°é›†ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦åˆ—å‡ºæ‰€æœ‰å¯¹ (x, y)ï¼Œå…¶ä¸­ x å’Œ y æ˜¯ S çš„å…ƒç´ å¹¶ä¸” xRy æˆç«‹ã€‚
1. the values of x in S: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15  
2. x^2 < y < (x+1)^2 list the ordered pairs (x, y) where xRy holds for each x in S  
3. For x=1, the values of y that satisfy xRy are 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15. So the ordered pairs are: `{(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15)}`  
4. For x=2, the values of y that satisfy xRy are 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15. So the ordered pairs are: `{(2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (2, 11), (2, 12), (2, 13), (2, 14), (2, 15)}`  
5. For x=3, the values of y that satisfy xRy are 10, 11, 12, 13, 14, 15. So the ordered pairs are: `{(3, 10), (3, 11), (3, 12), (3, 13), (3, 14), (3, 15)}`  
6. For x=4, the values of y that satisfy xRy are 17, 18, 19, 20, 21, 22, 23, 24, 25. However, since 25 is greater than 15, we can exclude it from our list of ordered pairs. So the ordered pairs are: `{(4, 17), (4, 18), (4, 19), (4, 20), (4, 21), (4, 22), (4, 23), (4, 24)}`  
7. For x=5, the values of y that satisfy xRy are 26, 27, 28, 29, 30, 31, 32, 33, 34 However, since all of these values are greater than 15, we can exclude them from our list of ordered pairs. So there are no ordered pairs for x=5.
8. For x= 6 ~ 15 is the same reason
9. Therefore, the set of ordered pairs in S that represent the relation R is: `{(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (1, 8), (1, 9), (1, 10), (1, 11), (1, 12), (1, 13), (1, 14), (1, 15), (2, 5), (2, 6), (2, 7), (2, 8), (2, 9), (2, 10), (2, 11), (2, 12), (2, 13), (2, 14), (2, 15), (3, 8), (3, 9), (3, 10), (3, 11), (3, 12), (3, 13), (3, 14), (3, 15), (4, 13), (4, 14), (4, 15)}`  
### Q4 Graph Theory
Given an undirected graph G with vertices V = {1, 2, 3, 4, 5, 6, 7, 8} and edges E = {12, 14, 16, 22, 23,  28, 34, 35, 67, 78}  
#### (a) Draw G graphically
![](../img/fit5171-20230316-5.png)
#### (b) Calculate the degree of each node in the graph
-   count the number of edges incident to each vertex. in an undirected graph, the degree of a node is equal to the number of edges incident to it, because each edge contributes to the degree of both of its endpoints. è®¡ç®—å…¥å°„åˆ°æ¯ä¸ªé¡¶ç‚¹çš„è¾¹æ•°ã€‚åœ¨æ— å‘å›¾ä¸­ï¼ŒèŠ‚ç‚¹çš„åº¦æ•°ç­‰äºå…¥å°„åˆ°å®ƒçš„è¾¹çš„æ•°é‡ï¼Œå› ä¸ºæ¯æ¡è¾¹éƒ½ä¼šå½±å“å…¶ä¸¤ä¸ªç«¯ç‚¹çš„åº¦æ•°ã€‚
-   degree(1) = 3

#### (c) Calculate the Cyclomatic number of G
The cyclomatic number, also known as the connectivity or the circuit rank, is a graph-theoretic measure that gives the minimum number of edges that need to be removed from a graph in order to disconnect it or make it acyclic. åœˆæ•°ï¼Œä¹Ÿç§°ä¸ºè¿é€šæ€§æˆ–ç”µè·¯ç­‰çº§ï¼Œæ˜¯ä¸€ç§å›¾è®ºåº¦é‡ï¼Œå®ƒç»™å‡ºäº†éœ€è¦ä»å›¾ä¸­åˆ é™¤çš„æœ€å°è¾¹æ•°ï¼Œä»¥ä¾¿æ–­å¼€å®ƒæˆ–ä½¿å…¶æˆä¸ºéå¾ªç¯çš„ã€‚ 
The formula for the cyclomatic number is: `c = |E| - |V| + k`  where |E| is the number of edges, |V| is the number of vertices, and k is the number of connected components in the graph.å…¶ä¸­|E|æ˜¯è¾¹æ•°ï¼Œ|V|æ˜¯é¡¶ç‚¹çš„æ•°é‡ï¼Œk æ˜¯å›¾ä¸­è¿é€šåˆ†é‡çš„æ•°é‡ã€‚
1. `|V| = 8` `|E| = 10 (counting each undirected edge once)` `k = 1 (because the graph is connected)` 
2. `c = |E| - |V| + k = 10 - 8 + 1 = 3` 
### Q5 
Letâ€™s treat G in Q5 as a directed graph (edge 12 in E represents an edge from node 1 to node 2)  V = {1, 2, 3, 4, 5, 6, 7, 8} and edges E = {12, 14, 16, 22, 23,  28, 34, 35, 67, 78}  
#### (a) Draw G graphically
![](../img/fit5171-20230316-4.png)
#### (b) Calculate the in-degree and out-degree of each node (ignoring edge 22 for this question)
in a directed graph, the in-degree of a node is the number of edges coming into it, while the out-degree of a node is the number of edges going out from it. åœ¨æœ‰å‘å›¾ä¸­ï¼ŒèŠ‚ç‚¹çš„å…¥åº¦æ˜¯è¿›å…¥å®ƒçš„è¾¹çš„æ•°é‡ï¼Œè€ŒèŠ‚ç‚¹çš„å‡ºåº¦æ˜¯ä»å®ƒå‡ºå»çš„è¾¹çš„æ•°é‡ã€‚


#### (c) Are there any source nodes or sink nodes in G?
A source node is a node with in-degree 0, meaning there are no incoming edges to that node. A sink node is a node with out-degree 0, meaning there are no outgoing edges from that node.æºèŠ‚ç‚¹æ˜¯å…¥åº¦ä¸º 0 çš„èŠ‚ç‚¹ï¼Œè¿™æ„å‘³ç€è¯¥èŠ‚ç‚¹æ²¡æœ‰ä¼ å…¥è¾¹ã€‚æ±‡èŠ‚ç‚¹æ˜¯å‡ºåº¦ä¸º 0 çš„èŠ‚ç‚¹ï¼Œè¿™æ„å‘³ç€è¯¥èŠ‚ç‚¹æ²¡æœ‰å‡ºè¾¹ã€‚

#### d) Does this graph contain semi-paths? If so, identify them.
A semi-path is a sequence of vertices in a directed graph where all edges go in the same direction. That is, it is a directed path that either starts from a source node or ends at a sink node.åŠè·¯å¾„æ˜¯æœ‰å‘å›¾ä¸­çš„ä¸€ç³»åˆ—é¡¶ç‚¹ï¼Œå…¶ä¸­æ‰€æœ‰è¾¹éƒ½åœ¨åŒä¸€æ–¹å‘ä¸Šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæ˜¯ä¸€æ¡æœ‰å‘è·¯å¾„ï¼Œè¦ä¹ˆä»æºèŠ‚ç‚¹å¼€å§‹ï¼Œè¦ä¹ˆåˆ°æ±‡èŠ‚ç‚¹ç»“æŸã€‚
-   Semi-path from source node 4: 4 -> 6 -> 7
-   Semi-path from source node 6: 6 -> 7
-   Semi-path to sink node 3: 2 -> 8 -> 5 -> 3
-   Semi-path to sink node 7: 1 -> 2 -> 8 -> 7
#### e) Identify a pair of nodes that are 0-connected, 1-connected, 2-connected, and 3-connected, if any  (ignoring edge 22 again)
two nodes are said to be k-connected if there exist at least k edge-disjoint directed paths between them. That is, there are k paths from the first node to the second node, and no two of these paths share any common edges.å¦‚æœä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´è‡³å°‘å­˜åœ¨ k æ¡è¾¹ä¸ç›¸äº¤çš„æœ‰å‘è·¯å¾„ï¼Œåˆ™ç§°è¿™ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯ k-è¿é€šçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹æœ‰ k æ¡è·¯å¾„ï¼Œå¹¶ä¸”è¿™äº›è·¯å¾„ä¸­æ²¡æœ‰ä¸¤æ¡å…±äº«ä»»ä½•å…¬å…±è¾¹ã€‚
-   0-connected pairs: There are no pairs of nodes that are 0-connected in G, because in a directed graph, two nodes must share at least one edge to be 0-connected.
-   1-connected pairs: (1,2), (2,3), (2,8), (3,5), (5,7), (6,7), (7,8)
-   2-connected pairs: (1,3), (1,5), (1,7), (4,2), (4,3), (4,5), (4,8), (6,2), (6,3), (6,5), (6,8)
-   3-connected pairs: (1,8), (4,7)
#### (f) Work out the reachability matrix for G
The reachability matrix for a directed graph is an adjacency matrix where the entry in row i and column j is 1 if there exists a directed path from node i to node j, and 0 otherwise.æœ‰å‘å›¾çš„å¯è¾¾æ€§çŸ©é˜µæ˜¯ä¸€ä¸ªé‚»æ¥çŸ©é˜µï¼Œå…¶ä¸­å¦‚æœå­˜åœ¨ä»èŠ‚ç‚¹ i åˆ°èŠ‚ç‚¹ j çš„æœ‰å‘è·¯å¾„ï¼Œåˆ™è¡Œ i å’Œåˆ— j ä¸­çš„æ¡ç›®ä¸º 1ï¼Œå¦åˆ™ä¸º 0ã€‚

```
//adjacency matrix
    1  2  3  4  5  6  7  8
--------------------------
1 | 0  1  0  1  1  0  0  0
2 | 0  0  1  0  1  0  0  1
3 | 0  0  0  0  1  0  1  0
4 | 0  0  0  0  1  0  0  1
5 | 0  0  0  0  0  0  1  1
6 | 0  0  0  0  0  0  1  1
7 | 0  0  0  0  0  0  0  1
8 | 0  0  0  0  0  0  0  0
```
the entry in row i and column j is 1 if and only if there exists a directed path from node i to node j. For example, the entry in row 1 and column 2 is 1 because there exists a directed path from node 1 to node 2, namely the path (1,2). The entry in row 2 and column 1, however, is 0 because there is no directed path from node 2 to node 1.å½“ä¸”ä»…å½“å­˜åœ¨ä»èŠ‚ç‚¹ i åˆ°èŠ‚ç‚¹ j çš„æœ‰å‘è·¯å¾„æ—¶ï¼Œç¬¬ i è¡Œå’Œç¬¬ j åˆ—ä¸­çš„æ¡ç›®ä¸º 1ã€‚ä¾‹å¦‚ï¼Œç¬¬1è¡Œç¬¬2åˆ—çš„æ¡ç›®ä¸º1ï¼Œå› ä¸ºå­˜åœ¨ä»èŠ‚ç‚¹1åˆ°èŠ‚ç‚¹2çš„æœ‰å‘è·¯å¾„ï¼Œå³è·¯å¾„(1,2)ã€‚ä½†æ˜¯ï¼Œç¬¬ 2 è¡Œå’Œç¬¬ 1 åˆ—ä¸­çš„æ¡ç›®ä¸º 0ï¼Œå› ä¸ºæ²¡æœ‰ä»èŠ‚ç‚¹ 2 åˆ°èŠ‚ç‚¹ 1 çš„å®šå‘è·¯å¾„ã€‚
### Q6 Draw a directed graph for each of the following common control constructs
![](../img/fit5171-20230316-6.png)    
(a) an if-then-else  
(b) a while loop  
(c) a natural loop with two exits, e.g. while with an if...break in the middle; non-structured but reducible  
(d) an irreducible CFG: a loop with two entry points, e.g. goto into a while or for loop
#### if-then
```
      +--------+
      |        |
      v        |
+-----------+  |
|  condition|  |
+-----------+  |
      |        |
      | true   | false
      v        |
+-----------+  |
|  action   |  |
+-----------+  |
      |        |
      +--------+

```
the condition node represents the boolean condition to be evaluated. If the condition is true, control flows to the action node, where some action is taken. If the condition is false, control simply continues on to the next node in the graph.æ¡ä»¶èŠ‚ç‚¹è¡¨ç¤ºè¦è¯„ä¼°çš„å¸ƒå°”æ¡ä»¶ã€‚å¦‚æœæ¡ä»¶ä¸ºçœŸï¼Œæ§åˆ¶æµå‘åŠ¨ä½œèŠ‚ç‚¹ï¼Œåœ¨è¯¥èŠ‚ç‚¹é‡‡å–ä¸€äº›åŠ¨ä½œã€‚å¦‚æœæ¡ä»¶ä¸ºå‡ï¼Œæ§åˆ¶å°†ç®€å•åœ°ç»§ç»­åˆ°å›¾ä¸­çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚
#### if-then-else
```
       +--------+
       |        |
       v        |
 +-----------+  |
 | condition |  |
 +-----------+  |
       |        |
       | true   | false
       v        |
 +-----------+  |
 |   then    |  |
 +-----------+  |
       |        |
       v        |
 +-----------+  |
 |   else    |  |
 +-----------+  |
       |        |
       v        |
 +-----------+  |
 |  after if |  |
 +-----------+  |

```
the condition node represents the boolean condition to be evaluated. If the condition is true, control flows to the then node, where some action is taken. If the condition is false, control flows to the else node, where a different action is taken. After either the then or else actions are taken, control flows to the after if node.æ¡ä»¶èŠ‚ç‚¹è¡¨ç¤ºè¦è¯„ä¼°çš„å¸ƒå°”æ¡ä»¶ã€‚å¦‚æœæ¡ä»¶ä¸ºçœŸï¼Œåˆ™æ§åˆ¶æµå‘ then èŠ‚ç‚¹ï¼Œåœ¨è¯¥èŠ‚ç‚¹é‡‡å–æŸäº›æ“ä½œã€‚å¦‚æœæ¡ä»¶ä¸ºå‡ï¼Œåˆ™æ§åˆ¶æµå‘ else èŠ‚ç‚¹ï¼Œåœ¨è¯¥èŠ‚ç‚¹æ‰§è¡Œä¸åŒçš„æ“ä½œã€‚åœ¨æ‰§è¡Œ then æˆ– else æ“ä½œä¹‹åï¼Œæ§åˆ¶æµå‘ after if èŠ‚ç‚¹ã€‚
#### case switch
```
       +-----------+
       |           |
       v           |
 +------------+   |
 | expression |   |
 +------------+   |
       |           |
       | case 1    | case 2
       v           |
 +------------+   |
 |   action   |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 |   action   |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 | default    |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 |   action   |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 |  after    |   |
 +------------+   |

```
the expression node represents the value whose different cases are evaluated. Depending on the value of the expression, control flows to one of the case nodes, where a specific action is taken. If none of the cases match, control flows to the default node, where a default action is taken. After the case or default actions are taken, control flows to the after node.è¡¨è¾¾å¼èŠ‚ç‚¹è¡¨ç¤ºè¯„ä¼°å…¶ä¸åŒæƒ…å†µçš„å€¼ã€‚æ ¹æ®è¡¨è¾¾å¼çš„å€¼ï¼Œæ§åˆ¶æµå‘å…¶ä¸­ä¸€ä¸ªæ¡ˆä¾‹èŠ‚ç‚¹ï¼Œåœ¨æ­¤æ‰§è¡Œç‰¹å®šæ“ä½œã€‚å¦‚æœæ‰€æœ‰æƒ…å†µéƒ½ä¸åŒ¹é…ï¼Œåˆ™æ§åˆ¶æµå‘é»˜è®¤èŠ‚ç‚¹ï¼Œåœ¨æ­¤å¤„æ‰§è¡Œé»˜è®¤æ“ä½œã€‚åœ¨é‡‡å– case æˆ– default æ“ä½œåï¼Œæ§åˆ¶æµå‘ after èŠ‚ç‚¹ã€‚
#### while loop
```
       +-----------+
       |           |
       v           |
 +------------+   |
 | condition  |   |
 +------------+   |
       |           |
       |  true     |
       v           |
 +------------+   |
 |   body     |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 |  after     |   |
 +------------+   |

```
the condition node represents the boolean condition to be evaluated before each iteration of the loop. If the condition is true, control flows to the body node, where some action is taken. After the action is taken, control flows back to the condition node to evaluate the condition again. If the condition is false, control flows to the after node.æ¡ä»¶èŠ‚ç‚¹è¡¨ç¤ºåœ¨å¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¹‹å‰è¦è¯„ä¼°çš„å¸ƒå°”æ¡ä»¶ã€‚å¦‚æœæ¡ä»¶ä¸ºçœŸï¼Œåˆ™æ§åˆ¶æµå‘ body èŠ‚ç‚¹ï¼Œåœ¨æ­¤æ‰§è¡ŒæŸäº›æ“ä½œã€‚é‡‡å–è¡ŒåŠ¨åï¼Œæ§åˆ¶æµå›æ¡ä»¶èŠ‚ç‚¹ä»¥å†æ¬¡è¯„ä¼°æ¡ä»¶ã€‚å¦‚æœæ¡ä»¶ä¸ºå‡ï¼Œæ§åˆ¶æµå‘åèŠ‚ç‚¹ã€‚
#### do-while loop
```
       +-----------+
       |           |
       v           |
 +------------+   |
 |   body     |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 | condition  |   |
 +------------+   |
       |           |
       |  true     |
       v           |
 +------------+   |
 |   body     |   |
 +------------+   |
       |           |
       v           |
 +------------+   |
 |  after     |   |
 +------------+   |

```
the body node represents the action to be taken in each iteration of the loop. After the action is taken, control flows to the condition node to evaluate the boolean condition. If the condition is true, control flows back to the body node to take the action again. If the condition is false, control flows to the after node. Note that the body node is executed at least once, regardless of the value of the condition. body èŠ‚ç‚¹è¡¨ç¤ºå¾ªç¯çš„æ¯æ¬¡è¿­ä»£ä¸­è¦é‡‡å–çš„æ“ä½œã€‚é‡‡å–è¡ŒåŠ¨åï¼Œæ§åˆ¶æµå‘æ¡ä»¶èŠ‚ç‚¹ä»¥è¯„ä¼°å¸ƒå°”æ¡ä»¶ã€‚å¦‚æœæ¡ä»¶ä¸ºçœŸï¼Œåˆ™æ§åˆ¶æµå›æ­£æ–‡èŠ‚ç‚¹ä»¥å†æ¬¡æ‰§è¡Œæ“ä½œã€‚å¦‚æœæ¡ä»¶ä¸ºå‡ï¼Œæ§åˆ¶æµå‘åèŠ‚ç‚¹ã€‚è¯·æ³¨æ„ï¼Œæ— è®ºæ¡ä»¶å€¼å¦‚ä½•ï¼Œä¸»ä½“èŠ‚ç‚¹è‡³å°‘æ‰§è¡Œä¸€æ¬¡ã€‚
# Assignment 1
```ad-note
title: Requirment
collapse:

This assignment carries 10 marks. The assessment will be based on the submitted files as well  as a demo/interview conducted in-tutorial in week5 
You will need to submit a test plan report and the project setup, contained in a single .zip file, to  Moodle. 
1.2 Test Plan document  
The report will include following parts:  The report should not exceed 4 pages in length
(1) testing objective,  
(2) scope of testing,  
(3) approach (including any assumption/constraints, software requirements to be tested, testing tools),  
(4) test plan (including testing team and test environment) and  
(5) testing procedure (including test execution and unit test cases). You should document test cases in a  tabular form (check the format in Week 2 lecture).
1.3 Project set up and testing requirements  
1. Maven project: We have provided Java files with no project structure. You need to create a  maven project and import these files into correct location.  
2. BuyTicket and ChooseTicket are required to be combined into one class. You can call this call  TicketSystem.  
3. Write code on any five test cases you created in the report. Test cases should test different  constraint
1.4 Demo  
Each group will also need to give a code walkthrough to a TA, showing your understanding of the code,  
and your test plan. All the team members will be interviewed. All the team members are required to  attend the same tutorial during week 5 tutorial

1.5 Assessment Breakdown  
5 marks - Testing documentation
5 marks - Setup and testing You need to show that you have successfully set up the local working environment and have developed  some test cases.  
Your report can contain screenshots showing that your setup is successful. If you ran into problems  setting up the environment, your report should briefly document the problem and the status of the setup  as an append
```

# Week 4  Blackbox Testing
## Lecture
### Blackbox testing  
![](../img/fit5171-20230404.png)
+ No knowledge of the internal structure  
+ Testing behaviour of the software  
+ Functional testing(å…·ä½“åŠŸèƒ½ï¼Œç™»é™†ï¼Œæ³¨å†Œç­‰) & non-functional testing (load testing, usability testing, etc.ç¨³å®šæ€§ï¼Œå®‰å…¨æ€§ï¼Œæ˜“ç”¨æ€§ç­‰)  
### Boundary Value Testing (BVT)
errors tend to occur near the boundary values for an input variable. test using variable values from the input (domain) of a program  
![](../img/fit5171-20230404-6.png)
#### Normal Boundary Value Testing (NBVT)
+ Focus on valid values of the input variables.   
+ Focus on valid values of the input variables (min, min+, nor, max, max-)  
+ NBVT => Single fault assumption Failures are usually caused by only one fault, not more  
+ Test cases:<mark style="background: #3CB371;">(nominal, boundary)(boundary, nominal) (nominal, nominal)</mark>  
+ One variable takes: min, min+, nor, max-, max <mark style="background: #0000CD;">Total 4n+1 cases</mark>
![](../img/fit5171-20230404-1.png)  
#### Robustness testing
![](../img/fit5171-20230404-2.png)  
+ Simple extension of boundary value analysis Add values min- & max+  
+ Purpose: exception handling  May cause runtime errors in strongly-typed languages  
+ total no. of test cases = 6n + 1  
#### Worst case testing  
![](../img/fit5171-20230404-3.png)  
+ Disregard single fault assumption, acquire more test cases  
+ for each variable Take min, min+, nor, max-, max Take the Cartesian product x 1 x x2  
+ <mark style="background: #ff0000;">test cases = 5 ^ n</mark> Applicable when failure is costly
#### Robust worst-case testing
![](../img/fit5171-20230404-5.png)  
+ Taking it one step further Add min- & max+  
+ <mark style="background: #3CB371;">test cases now = 7^n</mark>  Applicable when failure is  really costly
### Equivalence class testing
[Equivalence Class Testing: Complete Guide |Professionalqa.com](https://professionalqa.com/equivalence-class-testing)  
+ Basic idea: partition the entire input set into disjoint subsets  
+ Covering: complete testing  
+ Disjointness: no redundancy  
+ One test case from each equivalence class 
+ Key: find a good equivalence relation  
+ Weak equivalence and strong equivalence classes
#### example
```
a â‰¤ x1 â‰¤ d, with intervals [a,b), [b,c),  [c,d]  
e â‰¤ x 2 â‰¤ g, with intervals [e,f), [f,g]  Partition based on intervals  
V1 = { x1 : a â‰¤ x1 < b }  
V2 = { x1 : b â‰¤ x1 < c }  
V3 = { x1 : c â‰¤ x1 â‰¤ d }  
V4 = { x2 : e â‰¤ x2 < f }, V5 = { x2 : f â‰¤ x2 â‰¤ g }  
NV1 = { x1 : x1 < a }, NV2 = { x1 : x1 > d }  
NV3 = { x2 : x2 < e }, NV4 = { x2 : x2 > g }
```
![](../img/fit5171-20230404-8.png) 
Equivalent classes of valid values:  C x1 = { V1, V2, V3 }  C x2 = { V4, V5 }  
Equivalent classes of invalid values:  I x1 = { NV1, NV2 }   I x2 = { NV3, NV4 }
#### Weak equivalence class testing  
![](../img/fit5171-20230404-9.png)  
+ Weak normal  Choosing one valid value from each equivalent class (over valid interval)  
+ Weak robust  Test case include invalid values One invalid value => other valid values
#### Strong equivalence class testing
![](../img/fit5171-20230404-10.png)  
+ Strong normal  Choosing each element of cartesian  product of the equivalent classes  (valid interval  
+ Strong robust  Choosing each element of cartesian  product of all the equivalent classes  (both valid and invalid)
### Decision Table - based Testing
![](../img/fit5171-20230404-11.png)  
+ Guarantees completeness of testing => every possible combination of conditional  values (Conditions â†’ Actions)  
+ Cause-Effect table where Cause and effects  are captured for better test coverage
![](../img/fit5171-20230404-12.png)
![](../img/fit5171-20230404-13.png)
### Testing effort  
  
+ BVT - no recognition of data or logical dependencies  Mechanical, easy to automate    
+ ECT - need to consider data dependencies & program logic  Defining the equivalence relation  
+ DTT - need to consider both data & logical dependencies
![](../img/fit5171-20230404-14.png)
![](../img/fit5171-20230404-15.png)


## Tutorial
### 1. work out a formula for the number of test cases for each of the following  cases and briefly explain
#### (a) The robust BVT (with additional values minâˆ’ and max + for each variable) 
(n Ã— 2) + 1   
where n is the number of input variables in the program.  Â The (n Ã— 2) term in the formula represents the number of boundary values for each input variable that need to be tested. adds 1 to the number of test cases for the basic BVT to account for the additional values,
#### (b) Weak normal equivalence class testing

### 4. Under the tutorial resources, you will find a pdf document which includes the NextDate  method, which, given a day, a month, and a year, returns the date of the following day.
```
Rules must be complete  Conditions must cover all possibilities  
Rules must be exclusive  Given certain conditions, only one rule can be true  
D1 = {d: day | 1 â‰¤ d â‰¤ 27}  
D2 = {d: day | d = 28} = {28}  
D3 = {d: day | d = 29} = {29}  
D4 = {d: day | d = 30} = {30}  
D5 = {d: day | d = 31} = {31}
M1 = {m: month | m has 30 days}  
M2 = {m: month | m has 31 days except December}  
M3 = {m: month | m is December}  
M4 = {m: month | m is February}  
Y1 = {y: year | y is a leap year}  
Y2 = {y: year | y is a common year}
```
![](../img/fit5171-20230323.png)
#### Complete the decision table on slide 37 for NextDate by filling in the missing conditions and associated actions
| Rules      |    | 7      | 8     | 9   | 10    | 11 | 12 | 13 |
| ---------- | -- | ------ | ----- | --- | ----- | -- | -- | -- |
| Conditions | c1 | D1-D4, | D1,D2 | Â D3 | D4,D5 | D1 | D2 | D3 |
|            | C2 | M3     | M4    | M4  | M4    | M4 | M4 | M4 |
|            | C3 |        | Y1    | Y1  | Y1,Y2 | Y2 | Y2 | Y2 |
| Actions    | a1 |        |       |     | x     |    |    | x  |
|            | a2 | x      | x     |     |       | x  |    |    |
|            | a3 |        |       | x   |       |    | x  |    |
|            | a4 |        |       | x   |       |    | x  |    |
|            | a5 |        |       |     |       |    |    |    |
|            | a6 |        |       |     |       |    |    |    |

Rule 7: If the day is in the range D1-D4, month is February, and the year is a common year, then the following day of the given date will be 01-Mar.
Rule 8: If the day is 28, month is February, and the year is a leap year, then the following day of the given date will be 29-Feb.
Rule 9: If the day is 29, month is February, and the year is a leap year, then the following day of the given date will be 01-Mar.
Rule 10: If the day is in the range D4-D5, month is February, and the year is a leap or common year, then the following day of the given date does not exist and the output will be invalid.
Rule 11: If the day is in the range D1-D4, month is not February, and the year is a leap or common year, then the following day of the given date can be computed normally by moving to the next day.
Rule 12: If the day is 28, month is not February, and the year is a common year, then the following day of the given date will be 01-Mar.
Rule 13: If the day is 29 or 30, month is not February, and the year is a common year, then the following day of the given date will be the next day of the same month.


# week 5 White-box testing
## Lecture
### White-box testing
![](../img/fit5171-20230404-16.png)
+ Testing structure of the software  ä¸ä»…å…³æ³¨è¾“å…¥å’Œè¾“å‡ºï¼ŒåŒæ—¶å…³æ³¨ç›’å­å†…çš„ä»£ç ç»“æ„
+ Abstraction is the key Programs â†’ mathematical objects (models å°†ä»£ç è½¬æ¢æˆæ•°å­¦æ¨¡å‹  
+ Analyse the abstract program Data flow, control flow, coverage, etc.
### Program graph  
![](../img/fit5171-20230404-17.png)  
+ directed graph; Nodes: statement fragments;  Edges: flow of control;  Paths: program execution
+ Simplification: grouping of statements Basic blocks - sequential execution  
+ identify test cases {(1,2), (2,9)}  {(1,2), (2,3),(3,4),(4,3),(3,5), (5,7),(7,8),(8,2),(2,9)}
### Decision-to-decision paths DD-paths  
![](../img/fit5171-20230404-18.png)  
ä¸»è¦ç€çœ¼æµ‹è¯•è¦†ç›–ç‡é—®é¢˜ã€‚  
ç¨‹åºæœ‰å‘å›¾ä¸­å­˜åœ¨åˆ†æ”¯ï¼Œè¦†ç›–ç‡è€ƒè™‘çš„æ˜¯å¯¹å„ä¸ªåˆ†æ”¯æƒ…å†µçš„æµ‹è¯•è¦†ç›–ç¨‹åº¦ï¼Œå› æ­¤å¯¹æœ‰å‘å›¾ä¸­çº¿æ€§ä¸²è¡Œçš„ éƒ¨åˆ†è¿›è¡Œå‹ç¼©ï¼Œåœ¨å‹ç¼©å›¾(å³DD-è·¯å¾„)çš„åŸºç¡€ä¸Šè¿›è¡Œæµ‹è¯•ç”¨ä¾‹è®¾è®¡ï¼Œç”¨æµ‹è¯•è¦†ç›–æŒ‡æ ‡è€ƒå¯Ÿæµ‹è¯•æ•ˆæœ
```
Indegree: no. of incoming edges for a node  
Outdegree: no. of outgoing edges for a node  
Path: a sequence of adjacent edges  
2-connected: if there is a path between the two nodes
```
### Test coverage metrics  
Test coverage is a percentage measure of the degree to which the source code of  a program is executed when a particular test suite is run.  
![](../img/fit5171-20230404-19.png)
### Basis path testing  
Path testing is a structural testing method that involves using the source code of a  program in order to find every possible executable path.  It helps to determine all faults lying within a piece of code. This method is  designed to execute all or selected path through a computer program.  Any software program includes, multiple entry and exit points. Testing each of  these points is a challenging as well as time-consuming. In order to reduce the  redundant tests and to achieve maximum test coverage, basis path testing is used  
![](../img/fit5171-20230404-20.png)  
![](../img/fit5171-20230404-22.png)
![](../img/fit5171-20230404-21.png)  
![](../img/fit5171-20230404-23.png)  
# Week 6 Integration Testing
## Lecture
-   Objectives of integration testing
-   Integration testing approaches
	-   Decomposition-based
	-   Call graph-based
	-   Path-based
-   A comparison of different approaches
### Phases & goals of testing
![](../img/fit5171-20230404-24.png)  
### Integration testing
é›†æˆæµ‹è¯•æ˜¯åœ¨å•å…ƒæµ‹è¯•çš„åŸºç¡€ä¸Šï¼Œæµ‹è¯•åœ¨å°†æ‰€æœ‰çš„è½¯ä»¶å•å…ƒæŒ‰ç…§æ¦‚è¦è®¾è®¡è§„æ ¼  
è¯´æ˜çš„è¦æ±‚ç»„è£…æˆæ¨¡å—ã€å­ç³»ç»Ÿæˆ–ç³»ç»Ÿçš„è¿‡ç¨‹ä¸­å„éƒ¨åˆ†å·¥ä½œæ˜¯å¦è¾¾åˆ°æˆ–å®ç°ç›¸  
åº”æŠ€æœ¯æŒ‡æ ‡åŠè¦æ±‚çš„æ´»åŠ¨ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨é›†æˆæµ‹è¯•ä¹‹å‰ï¼Œå•å…ƒæµ‹è¯•åº”è¯¥å·²ç»å®Œ  
æˆï¼Œé›†æˆæµ‹è¯•ä¸­æ‰€ä½¿ç”¨çš„å¯¹è±¡åº”è¯¥æ˜¯å·²ç»ç»è¿‡å•å…ƒæµ‹è¯•çš„è½¯ä»¶å•å…ƒ
+ System - hierarchically composed of units  
+ Objectives - testing of interfacing and interaction of units; To expose problems arising from the combination; To find a working solution from component 
+ Internal - between components å•å…ƒé—´çš„æ¥å£ï¼ŒæŒ‡çš„æ˜¯ä»£ç é—´çš„ç›¸äº’è°ƒç”¨ï¼Œæˆ‘ä»¬ä¼ é€’  
ä¸€äº›å‚æ•°æ¥åˆ¤æ–­æµ‹è¯•è°ƒç”¨æœ‰æ²¡æœ‰é—®é¢˜  
	- Method invocation - calls/message passing  
	- Parameter - types, values, order, etc.  
	- Method return - identity, types, sequence,  
- External - outside of system Interrupts, I/O timing, etcé›†æˆåçš„åŠŸèƒ½ï¼Œä¸åŒçš„åŠŸèƒ½ä¹‹é—´æ˜¯å¦ä¼šäº§ç”Ÿç›¸äº’å½±å“
![](../img/fit5171-20230404-25.png)
![](../img/fit5171-20230404-37.png)
### Decomposition-based Integration testing
Decompose the system in different ways åŸºäºåˆ†è§£ï¼ŒåŠŸèƒ½åˆ†è§£ï¼Œæ¨¡å—åˆ†è§£: 
+ System Architecture: hierarchically composed of components Organised in layers
+ Layers of components
  
### Structural integration approaches: 
![](../img/fit5171-20230404-27.png)
#### Big bang
![](../img/fit5171-20230404-26.png)

 + all units together, no error localisation 
 + è¿…é€Ÿï¼ˆå¦‚æœæ‰§è¡Œæ²¡æœ‰é—®é¢˜çš„è¯ï¼‰å®Œæˆé›†æˆæµ‹è¯•ï¼Œå¹¶ä¸”åªè¦æå°‘æ•°çš„é©±åŠ¨å’Œæ¡©æ¨¡å—è®¾è®¡ï¼Œå®ƒéœ€è¦çš„æµ‹è¯•ç”¨ä¾‹ä¹Ÿæ˜¯æœ€å°‘çš„  
 + å°†æ‰€æµ‹æ¨¡å—è¿æ¥èµ·æ¥è¿›è¡Œæµ‹è¯•ä¸€æ¬¡è¯•è¿è¡ŒæˆåŠŸç‡ä¸å¤§ï¼Œå¯¼è‡´æµ‹è¯•æ•ˆç‡æ¯”è¾ƒä½  
 + å…¶é—®é¢˜å®šä½å’Œä¿®æ”¹éƒ½æ¯”è¾ƒå›°éš¾  
 + é€‚ç”¨ä¸€ä¸ªç»´æŠ¤å‹é¡¹ç›®ï¼ˆæˆ–åŠŸèƒ½å¢å¼ºå‹é¡¹ç›®ï¼‰ï¼Œå…¶ä»¥å‰çš„äº§å“å·²ç»å¾ˆç¨³å®šäº†  
 + è¢«æµ‹ç³»ç»Ÿæ¯”è¾ƒå°ï¼Œå¹¶ä¸”å®ƒçš„æ¯ä¸ªå‡½æ•°éƒ½ç»è¿‡å……åˆ†çš„å•å…ƒæµ‹è¯•  

#### Top down
  ![](../img/fit5171-20230404-28.png)
+ stubs(æ¡©ï¼šæ¨¡æ‹Ÿçš„å­æ¨¡å—dummy component simulate the input-output behaviours of the called unit (methods | sub-systems )), early demo  
+ è¾ƒæ—©çš„éªŒè¯äº†ä¸»è¦çš„æ§åˆ¶å’Œåˆ¤æ–­ç‚¹å¯ä»¥é¦–å…ˆå®ç°å’ŒéªŒè¯ä¸€ä¸ªå®Œæ•´çš„è½¯ä»¶åŠŸèƒ½  
+ æ”¯æŒæ•…éšœéš”ç¦»  
+ Difficult to write when called unit has complex parameter  
+ åº•å±‚ç»„ä»¶è¡Œä¸ºçš„éªŒè¯è¢«æ¨è¿Ÿ åº•å±‚ç»„ä»¶çš„æµ‹è¯•ä¸å¤Ÿå……åˆ†  
+ é€‚åˆäº§å“æ§åˆ¶ç»“æ„ç›¸å¯¹æ¸…æ™°å’Œç¨³å®šï¼Œäº§å“çš„é«˜å±‚æ¥å£å˜åŒ–æ¯”è¾ƒå°  
#### Bottom up  
![](../img/fit5171-20230404-29.png)
+ terminal, drivers(é©±åŠ¨å™¨ï¼šæ¨¡æ‹Ÿçš„çˆ¶èŠ‚ç‚¹dummy component emulating not-yet-implemented behaviour of a calling unit (upper lever components))  
+ è¯¥ç­–ç•¥å…è®¸å¯¹åº•å±‚ç»„ä»¶è¡Œä¸ºçš„æ—©æœŸéªŒè¯ï¼Œå¯ä»¥åœ¨ä»»ä½•ä¸€ä¸ªå¶å­èŠ‚ç‚¹å·²ç»å°±ç»ªçš„æƒ…å†µä¸‹è¿›è¡Œé›†æˆæµ‹è¯•  
+ æ”¯æŒæ•…éšœéš”ç¦»  
+ å¯¹äºé«˜å±‚çš„éªŒè¯è¢«æ¨è¿Ÿåˆ°äº†æœ€åï¼Œè®¾è®¡ä¸Šçš„é”™è¯¯ä¸èƒ½è¢«åŠæ—¶å‘ç°  
+ åº•å±‚æ¥å£æ¯”è¾ƒç¨³å®šã€å˜åŠ¨è¾ƒå°‘çš„äº§å“.é«˜å±‚æ¥å£å˜åŒ–æ¯”è¾ƒé¢‘ç¹çš„äº§å“åº•å±‚ç»„ä»¶è¾ƒæ—©è¢«å®Œæˆçš„äº§å“

#### Sandwich
![](../img/fit5171-20230404-30.png)
+ a combination of the above methods  
+ ä¸­é—´ä¸€å±‚ä¸ºç›®æ ‡å±‚ å¯¹ç›®æ ‡å±‚çš„ä¸Šä¸€å±‚ä½¿ç”¨è‡ªé¡¶å‘ä¸‹çš„é›†æˆç­–ç•¥ å¯¹ç›®æ ‡çš„ä¸‹ä¸€å±‚ä½¿ç”¨è‡ªåº•å‘ä¸Šçš„é›†æˆç­–ç•¥ï¼Œæœ€åæµ‹è¯•åœ¨ç›®æ ‡å±‚ä¼šåˆ  
+ é›†åˆäº†è‡ªåº•å‘ä¸Šå’Œè‡ªé¡¶å‘ä¸‹è¿™ä¸¤ç§ç­–ç•¥çš„ä¼˜ç‚¹  
+ ä¸­é—´å±‚åœ¨è¢«é›†æˆå‰æµ‹è¯•ä¸å¤Ÿå……åˆ†  
+ å¤§éƒ¨åˆ†è½¯ä»¶å¼€å‘é¡¹ç›®éƒ½å¯ä½¿ç”¨è¯¥ç­–ç•¥  
+ ä¸Šå±‚æ›´å¤šçš„æ˜¯åé‡äºé«˜å±‚çš„ç»„ä»¶å¼€å‘ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨è‡ªé¡¶å‘ä¸‹çš„ç­–ç•¥é›†æˆï¼›
+ è€Œä¸‹å±‚åé‡äºå…·ä½“çš„ç»„ä»¶å®ç°,æˆ‘ä»¬é‡‡ç”¨è‡ªåº•å‘ä¸Šçš„ç­–ç•¥æ¥é›†æˆï¼›
+ ä¸­é—´éƒ¨åˆ†å¯èƒ½å°±æ˜¯ä¸€äº›æ¥å£å®ç°äº†ï¼Œå®Œäº‹ä¸Šä¸‹å±‚åœ¨ä¸­é—´å±‚ä¼šåˆï¼›
+ å®Œäº‹ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®ƒä»¬çš„æœ€å¤–æˆé‡‡ç”¨å¤§çˆ†ç‚¸æ–¹å¼é›†æˆä¹Ÿæ˜¯å¯ä»¥çš„

### Call graph-based integration
+ Directed graphs for calling relationships between components (methods, classes,  subroutines, units  
+ More behavioural, less structured  
+ Avoid impossible edges, stubs, drivers  
+ Aligns better with development/builds  
+ More difficult fault isolation All neighbours of a faulty unit need to be retested

#### Pairwise integration  
Integration testing of pairs of units Use actual code No stubs or drivers  
![](../img/fit5171-20230404-31.png)
#### Neighbour integration
Neighbour: edge distance; Neighbour integration: include neighbouring nodes  
![](../img/fit5171-20230404-32.png)  
### Path-based
+ Hybrid method - functional testing + structural testing  
+ Testing cases: behavioural threads  
+ interactions(behavioural) rather than interfaces(structural)  
+ Closely coupled with actual system behaviour Works well for Object Oriented  Programs  
![](../img/fit5171-20230404-33.png)
![](../img/fit5171-20230404-34.png)  
![](../img/fit5171-20230404-35.png)  
![](../img/fit5171-20230404-36.png)
### Mocking
Mocking is a technique used in unit and integration testing to simulate the behavior of an object or component that is not yet available or that would be too complex or costly to include in the testing environment.  
+ Â isolate the code that they want to test, by replacing any dependencies with mock objects or stubs that mimic the behavior of the real objects  
+ Increases test coverage: Mocking components or objects can help developers test edge cases and scenarios that would otherwise be difficult to replicate  
+ Speeds up testing: Use of mocks can eliminate the need to wait for slow or unavailable components  
+ Facilitates parallel testing: Mocking can easily allow multiple tests to be run in parallel wit out any interference from the other components which are not yet developed. 
```java
public class Calculator {
    private Database db;
    public Calculator(Database db) {
        this.db = db;
    }
    public int add(int a, int b) {
        int result = a + b;
        db.persist(result);
        return result;
    }
}
public class Database {
    public void persist(int result) {
        // logic to persist the result in the database
    }
}

```

```java
public class CalculatorTest {
    @Test
    public void testAdd() {
        // create mock Database object
        Database db = Mockito.mock(Database.class);
        // create Calculator object with mock Database dependency
        Calculator calc = new Calculator(db);
        // call add method on Calculator
        int result = calc.add(2, 3);
        // verify that add method returned correct result
        assertEquals(5, result);
        // verify that persist method was called on the mock Database object
        Mockito.verify(db).persist(5);
    }
}

```

## Tutorial
### Q1 
![](../img/fit5171-20230405.png)  
simple Web application for management of personnel, which deals with classes `Persons, Expertise, Missions, Invitations` the interactions between components for the loading of a Mission page is shown below in Figure 1, showing the authentication & authorisation control flow  
+ `Router` is responsible for routing HTTP requests to the appropriate resources  that handles them   
+ `MissionRoute`  is responsible for creating pages to present mission details. once it is determined that authentication and authorisation the resource consults the `LoginManager` 
+ `LoginManager` to grant/refuse access based on user input. The LoginManager in turn invokes UserDAO  
+ `UserDAO` to load user details given the user name. If access is granted or that access control is not required, the resource then invokes MissionDAO  
+ `MissionDAO` to obtain mission details. If the user is denied access, it constructs a page to show the error accordingly. Finally, MissionRoute returns the page back to the Router.
#### Q1-a List all MM-paths for all the 5 components above
List all MM-paths for all the 5 components above. You can use letters A, B, C, D and E  to represent the 5 components in Figure 1. Recall that an MM-path starts from a source  node and ends at a sink node, with no intervening sink nodes.    
For example, the MM-path for component D (UserDAO) is MEP (D, 1) = (1, 2, 3). The MM-path for component E (MissionDAO) is MEP (E , 1) = (1, 2, 3)  
```
MEP(A,1) = (1,2,3,5) MEP(A,2) = (1,2,4) MEP(A,3) = (5)  
MEP(B,1) = (1,2,3,8) MEP(B,2) = (1,2,4) MEP(B,3) = (5,6,8) MEP(B,4) = (5,7) MEP(B,5) = (8)  
MEP(C,1) = (1,2) MEP(C,2) = (3,4,8) MEP(C,3) = (3,5,6,8) MEP(C,4) = (3,5,7,8)
```
[wc\_logical | Lucidchart](https://lucid.app/lucidchart/7fd1cddf-b1d1-4406-9fa0-3a22457fe58c/edit?viewport_loc=-17%2C184%2C1579%2C783%2CUK-LoNa_GiR-&invitationId=inv_67158b1b-e431-4bc4-acad-78d755496f4d)  
#### Q1-b Based on the  above MM-paths you developed in part
1. Draw the MM-path graph for the components.   
2. Calculate the MM-path complexity for the graph you just drew.

### Q2 Rate the relative fault isolation capabilities of the following integration strategies 
```
Rate the relative fault isolation capabilities of the following integration strategies   
1. Big bang  
2. Decomposition-based top-down integration   
3. Decomposition-based bottom-up integration   
4. Call graph-based neighbourhood integration (radius 1) 
Please also provide rationales for your choices.
```
1.  Decomposition-based bottom-up integration[Bottom up](#Bottom%20up): This strategy involves integrating modules from the bottom layer up, in order of their dependence on other modules. This allows for early detection and isolation of faults, as any issues with lower-level modules will be revealed before higher-level modules are integrated. This approach is often referred to as "test early and often" and is the most effective way to identify and isolate defects.  
2. Decomposition-based top-down integration[Top down](#Top%20down): This strategy involves integrating modules from the top layer down, in order of their calling relationships. This means that higher-level modules will be integrated before lower-level ones, which can make it more difficult to identify and isolate faults.  
3.  Call graph-based neighbourhood integration (radius 1)[Neighbour integration](#Neighbour%20integration): This strategy involves integrating modules that are closely related to each other, based on their calling relationships. By integrating neighboring modules, issues are more likely to be isolated within a small area of the program, which makes debugging easier.  
4.  Big bang[Big bang](#Big%20bang): This strategy involves integrating all modules at once, without any intermediate testing. This is the least effective strategy, as any faults that arise may be difficult to isolate and may require significant backtracking to fix. This approach can be very time-consuming, as it is difficult to identify where the issue lies. It is also difficult to verify that all modules are working correctly, as failures can cascade throughout the system.
### Q3 some of the benefits brought by mocking
+ Â isolate the code that they want to test, by replacing any dependencies with mock objects or stubs that mimic the behavior of the real objects  
+ Increases test coverage: Mocking components or objects can help developers test edge cases and scenarios that would otherwise be difficult to replicate  
+ Speeds up testing: Use of mocks can eliminate the need to wait for slow or unavailable components  
+ Facilitates parallel testing: Mocking can easily allow multiple tests to be run in parallel wit out any interference from the other components which are not yet developed. 
### Q4 Explain some of the difficulties in TDD for UserHandler without mocking.  
it is decided that an additional  layer of abstraction will be added to handle the storage of Users that adds additional functionality  (e.g., validation) on top of the underlying DAO layer. This new class is called UserHandler and  it will interact with UserDAO to achieve its functionalities.  
UserHandler class interacts with UserDAO which interacts with the database. 
without mocking would require an actual connection to the database, which can be time-consuming and make the tests slow.  
there could be many test cases that require specific data to be present in the database, which can be challenging to set up  
there could be issues with data consistency since the tests will be updating, inserting, and deleting data in the actual database. This can lead to unexpected behavior and make it difficult to isolate issues that arise during testing.

### Q5 how to apply Mocking 
[Unit tests with Mockito - Tutorial](https://www.vogella.com/tutorials/Mockito/article.html)  
[A Unit Testerâ€™s Guide to Mockito | ToptalÂ®](https://www.toptal.com/java/a-guide-to-everyday-mockito)  
Study the Mockito documentation to learn how the following is done.  
1. Creating a mock object : simply call theÂ `mock()`Â method, passing in a class or interface that you want to mock `MyClass myMock = Mockito.mock(MyClass.class);`
2. Specifying expected return results when a certain method is called use Mockito'sÂ `when()/thenReturn()`Â method chaining.`MyClass myMock = Mockito.mock(MyClass.class); when(myMock.someMethod()).thenReturn("expected result");`  This tells Mockito to return the string "expected result" when theÂ `someMethod()`Â method is called onÂ `myMock`.
3. Add partial mocking support to real objects use Mockito'sÂ `spy()`Â method, which wraps the real object and allows you to override specific methods.
```java
// Create a real object of MyClass:
MyClass myRealObject = new MyClass();

// Create a spy object of MyClass:
MyClass mySpy = Mockito.spy(myRealObject);

// Override the return result of someMethod() when it's called on the spy object:
when(mySpy.someMethod()).thenReturn("mocked result");

// Use mySpy object in your tests, as you would with any other mock object:
String result = mySpy.someMethod();

```

### Q6 implement new method with mocking
Suppose that we want to implement UserHandler.updatePassword(Long, String), which  takes 2 parameters: a Long value representing a Userâ€™s ID, and a String value representing  the new password value. updatePassword() returns true if the update is successful and false  otherwise. Two conditions can make an update fail:  
1. A null password is provided as the parameter value, or  
2. The new password is the same as the current one.  
Moreover, if no User object can be retrieved with the given ID, updatePassword should throw  an SQLException.  
Implement the above method in UserHandler class. Note that this class should make use of UserDAO class to access the database.
```java
public class UserHandler {
    private final UserDAO userDAO;

    public UserHandler(UserDAO userDAO) {
        this.userDAO = userDAO;
    }

    public boolean updatePassword(Long userId, String newPassword) throws SQLException {
        // Check if the password is null or empty
        if (newPassword == null || newPassword.isEmpty()) {
            return false;
        }

        User user = userDAO.getUserById(userId);

        // Check if a user with the given ID was found
        if (user == null) {
            throw new SQLException("User not found with ID: " + userId);
        }

        // Check if the new password is the same as the current password
        if (newPassword.equals(user.getPassword())) {
            return false;
        }

        user.setPassword(newPassword);

        return userDAO.updateUser(user);
    }
}

```
### Q7 Mockito with database
Develop test cases for the UserHandler class. Decide whether/when to use Mockito. Suppose  you want to test for the following scenarios.  
1. Null person to be retrieved from a given ID.  
2. Null password provided as the parameter value.  
3. New password same as the current one
```java
import java.sql.SQLException;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

public class UserHandlerTest {

    private UserHandler userHandler;
    private UserDAO mockUserDAO;

    @Before
    public void setUp() {
        mockUserDAO = Mockito.mock(UserDAO.class);
        userHandler = new UserHandler(mockUserDAO);
    }
//Null person to be retrieved from a given ID
    @Test(expected = SQLException.class)
    public void testUpdatePasswordUserNotFound() throws SQLException {
        Long userId = 1L;
        String newPassword = "newPassword";

        // Stub the UserDAO to return null when getUserById method is called
        Mockito.when(mockUserDAO.getUserById(userId)).thenReturn(null);

        // Call the updatePassword method
        boolean result = userHandler.updatePassword(userId, newPassword);

        // Verify that the result is false
        Assert.assertFalse(result);

        // Should throw SQLException since no user is found with the given ID
    }
//Null password provided as the parameter value.  
    @Test
    public void testUpdatePasswordNullPassword() throws SQLException {
        Long userId = 1L;
        String newPassword = null;

        // Call the updatePassword method
        boolean result = userHandler.updatePassword(userId, newPassword);

        // Verify that the result is false
        Assert.assertFalse(result);
    }
//New password same as the current one
    @Test
    public void testUpdatePasswordSamePassword() throws SQLException {
        Long userId = 1L;
        String oldPassword = "password";
        String newPassword = "password";

        // Create a User object with the old password
        User user = new User();
        user.setId(userId);
        user.setPassword(oldPassword);

        // Stub the UserDAO to return the User object when getUserById method is called
        Mockito.when(mockUserDAO.getUserById(userId)).thenReturn(user);

        // Call the updatePassword method
        boolean result = userHandler.updatePassword(userId, newPassword);

        // Verify that the result is false
        Assert.assertFalse(result);
    }

}

```
## Quiz 6 Work out the program graph of knuth morris pratt algorithm
[Knuthâ€“Morrisâ€“Pratt algorithm - Wikipedia](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm) searches for occurrences of a "word"Â `W`Â within a main "text string"Â `S`Â by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.  
```python
def kmp_search(pattern, text):
    """
    Search for the pattern string in the given text string 
    using the Knuth-Morris-Pratt algorithm.
    Returns a list of indices where the pattern is 
    found in the text, or an empty list if not found.
    """
    m = len(pattern)
    n = len(text)

    if m == 0:
        return [0]

    if n == 0:
        return []

    # Construct the failure function
    f = [0] * m
    j = 0

    for i in range(1, m):
        while j > 0 and pattern[j] != pattern[i]:
            j = f[j-1]

        if pattern[j] == pattern[i]:
            j += 1

        f[i] = j

    # Perform the search
    j = 0
    indices = []

    for i in range(n):
        while j > 0 and pattern[j] != text[i]:
            j = f[j-1]

        if pattern[j] == text[i]:
            j += 1

        if j == m:
            indices.append(i-m+1)
            j = f[j-1]

    return indices
    
pattern = "abc"
text = "abcbabcabcdabc"
kmp_search(pattern, text)

``` 
![](../img/fit5171-20230406.png)
![](../img/fit5171-20230406-2.png)
![](../img/fit5171-20230406-1.png)  
# Week7 Mocking and Software Integration Testing
know how Mockito Framework works.
çŸ¥é“ Mockito æ¡†æ¶æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚
How to mock objects for the testing purpose.
å¦‚ä½•ä¸ºæµ‹è¯•ç›®çš„æ¨¡æ‹Ÿå¯¹è±¡ã€‚
[Mockito Framework:](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)  
## Quiz
Consider a hospital data system, and one of the key features of this system is to retrieve a list of patients admitted to the hospital at that time. Using mockito, create a dummy implementation for this service and write one test case for it.  
Consider the following interface for the hospital data system, which defines the behavior for retrieving a list of patients:  
è€ƒè™‘ä»¥ä¸‹åŒ»é™¢æ•°æ®ç³»ç»Ÿçš„æ¥å£ï¼Œå®ƒå®šä¹‰äº†æ£€ç´¢æ‚£è€…åˆ—è¡¨çš„è¡Œä¸ºï¼š
```java
public interface PatientService {
    List<Patient> getAdmittedPatients();
}

```
To create a dummy implementation of this service, we can use Mockito to create a mock object of theÂ `PatientService`Â interface, and then specify an expected return value for theÂ `getAdmittedPatients()`Â method:  
è¦åˆ›å»ºæ­¤æœåŠ¡çš„è™šæ‹Ÿå®ç°ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ Mockito åˆ›å»ºÂ `PatientService`Â æ¥å£çš„æ¨¡æ‹Ÿå¯¹è±¡ï¼Œç„¶åä¸ºÂ `getAdmittedPatients()`Â æ–¹æ³•æŒ‡å®šé¢„æœŸçš„è¿”å›å€¼ï¼š
```java
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.runners.MockitoJUnitRunner;
import java.util.ArrayList;
import java.util.List;
import static org.junit.Assert.*;

@RunWith(MockitoJUnitRunner.class)
public class HospitalDataSystemTest {

    @Test
    public void testAdmittedPatients() {
        // create mock object of PatientService
        PatientService patientService = Mockito.mock(PatientService.class);

        // specify expected return value for getAdmittedPatients()
        List<Patient> expectedPatients = new ArrayList<>();
        expectedPatients.add(new Patient("John", "Doe"));
        expectedPatients.add(new Patient("Jane", "Doe"));
        when(patientService.getAdmittedPatients()).thenReturn(expectedPatients);

        // test method that uses getAdmittedPatients()
        List<Patient> actualPatients = patientService.getAdmittedPatients();
        assertEquals(expectedPatients.size(), actualPatients.size());
        for (int i = 0; i < expectedPatients.size(); i++) {
            assertEquals(expectedPatients.get(i).getFirstName(), actualPatients.get(i).getFirstName());
            assertEquals(expectedPatients.get(i).getLastName(), actualPatients.get(i).getLastName());
        }
    }
}

```
In this example, we have created a test method calledÂ `testAdmittedPatients()`. This method creates a mock object ofÂ `PatientService`Â using Mockito, and then specifies an expected return value for theÂ `getAdmittedPatients()`Â method using theÂ `when()`Â andÂ `thenReturn()`Â methods.  
åœ¨æ­¤ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåä¸ºÂ `testAdmittedPatients()`Â çš„æµ‹è¯•æ–¹æ³•ã€‚è¯¥æ–¹æ³•ä½¿ç”¨ Mockito åˆ›å»ºä¸€ä¸ªÂ `PatientService`Â çš„ mock å¯¹è±¡ï¼Œç„¶åä½¿ç”¨Â `when()`Â å’ŒÂ `thenReturn()`Â æ–¹æ³•ä¸ºÂ `getAdmittedPatients()`Â æ–¹æ³•æŒ‡å®šä¸€ä¸ªé¢„æœŸçš„è¿”å›å€¼ã€‚

We then test theÂ `PatientService`Â method by callingÂ `getAdmittedPatients()`Â and comparing the expected and actual values. In this case, we create a list of two sample patients and specify that this is the expected return value for theÂ `getAdmittedPatients()`Â method.  
ç„¶åæˆ‘ä»¬é€šè¿‡è°ƒç”¨Â `getAdmittedPatients()`Â å¹¶æ¯”è¾ƒé¢„æœŸå€¼å’Œå®é™…å€¼æ¥æµ‹è¯•Â `PatientService`Â æ–¹æ³•ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªæ ·æœ¬æ‚£è€…çš„åˆ—è¡¨ï¼Œå¹¶æŒ‡å®šè¿™æ˜¯Â `getAdmittedPatients()`Â æ–¹æ³•çš„é¢„æœŸè¿”å›å€¼ã€‚

Note that we are using theÂ `MockitoJUnitRunner`Â to run our test, which prepares the test environment for Mockito and makes it easy to use Mockito in our tests.  
è¯·æ³¨æ„ï¼Œæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨Â `MockitoJUnitRunner`Â æ¥è¿è¡Œæˆ‘ä»¬çš„æµ‹è¯•ï¼Œå®ƒä¸º Mockito å‡†å¤‡äº†æµ‹è¯•ç¯å¢ƒï¼Œå¹¶ä½¿å¾—åœ¨æˆ‘ä»¬çš„æµ‹è¯•ä¸­ä½¿ç”¨ Mockito å˜å¾—å®¹æ˜“ã€‚

# Assignment2
[Mockito (Mockito 5.3.1 API)](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#mock-java.lang.Class-) mockito æ–‡æ¡£
![](../img/fit5171-20230425-1.png)
![](../img/fit5171-20230425.png)
![](../img/fit5171-20230425-3.png)
[How to test standard in and out in Java - Dan Vega](https://www.danvega.dev/blog/2020/12/16/testing-standard-in-out-java/) Junit test Scanner
![](../img/fit5171-20230425-4.png)
![](../img/fit5171-20230425-5.png)


# Week 8 Software Quality and Metrics
## Learning Objectives:Â å­¦ä¹ ç›®æ ‡ï¼š
-   know different aspects of software quality metrics  äº†è§£è½¯ä»¶è´¨é‡æŒ‡æ ‡çš„ä¸åŒæ–¹é¢
-   measure, evaluate and analyse software under test using different quality and complexity metrics ä½¿ç”¨ä¸åŒçš„è´¨é‡å’Œå¤æ‚æ€§æŒ‡æ ‡æµ‹é‡ã€è¯„ä¼°å’Œåˆ†æè¢«æµ‹è½¯ä»¶

# week 9
## Quiz
Mutation testing is a technique to assess the efficacy and quality of a test suite. It works by making mutants, syntactic variations of the program under test, and measuring how many of the mutants are killed by the test suite. The presence of non-equivalent live mutants represents inadequacy of the test suite.
The following Java method, max, returns the largest of the three integer parameters.
```java
public int max(int a,int b,int c)
{
int temp a;
if (b > a) { temp = b;}

if (c > b) { temp = c;}
return temp;
}
```
Come up with three non-equivalent mutants of the original program, each making use one of the following mutation operators. 
Determine the kill rate of your test suite on each of the three mutants.
Note: The mutation operators you can use are:
ror: Relational operator replacement.
sdl: Statement deletion.
uoi: Unary operator insertion.
scr: Scalar variable replacement.
vie: Scalar variable initialisation elimination.  
Here are three non-equivalent mutants of the originalÂ `max`Â method, each making use of one of the mutation operators:  
ä»¥ä¸‹æ˜¯åŸå§‹Â `max`Â æ–¹æ³•çš„ä¸‰ä¸ªéç­‰æ•ˆçªå˜ä½“ï¼Œæ¯ä¸ªçªå˜ä½“éƒ½ä½¿ç”¨å…¶ä¸­ä¸€ä¸ªçªå˜è¿ç®—ç¬¦ï¼š

1.  `ror`Â - Relational operator replacement:  
    `ror`Â - å…³ç³»è¿ç®—ç¬¦æ›¿æ¢ï¼š

```
public int max(int a, int b, int c) {
    int temp = a;
    if (b >= a) { temp = b; }
    if (c > b) { temp = c; }
    return temp;
}
```

Copy Code

This mutant replaces theÂ `>`Â operator withÂ `>=`Â in the firstÂ `if`Â statement. The test case(s) that check for the case where all three integers are equal will fail to notice the mutation.  
æ­¤çªå˜ä½“åœ¨ç¬¬ä¸€ä¸ªÂ `if`Â è¯­å¥ä¸­å°†Â `>`Â è¿ç®—ç¬¦æ›¿æ¢ä¸ºÂ `>=`Â ã€‚æ£€æŸ¥æ‰€æœ‰ä¸‰ä¸ªæ•´æ•°éƒ½ç›¸ç­‰çš„æƒ…å†µçš„æµ‹è¯•ç”¨ä¾‹å°†ä¸ä¼šæ³¨æ„åˆ°çªå˜ã€‚

2.  `vie`Â - Variable initialization elimination:  
    `vie`Â - å˜é‡åˆå§‹åŒ–æ¶ˆé™¤ï¼š

```
public int max(int a, int b, int c) {
    int temp;
    if (b > a) { temp = b; }
    if (c > b) { temp = c; }
    return temp;
}
```

Copy Code

This mutant removes the initialization ofÂ `temp`Â toÂ `a`. The test case(s) that cover the case whereÂ `a`Â is the largest number will fail to notice the mutation.  
è¿™ä¸ªçªå˜ä½“ç§»é™¤äº†Â `temp`Â åˆ°Â `a`Â çš„åˆå§‹åŒ–ã€‚æ¶µç›–Â `a`Â æ˜¯æœ€å¤§æ•°å­—çš„æƒ…å†µçš„æµ‹è¯•ç”¨ä¾‹å°†æ— æ³•æ³¨æ„åˆ°çªå˜ã€‚

3.  `sdl`Â - Statement deletion:  
    `sdl`Â - è¯­å¥åˆ é™¤ï¼š

```
public int max(int a, int b, int c) {
    int temp = a;
    if (c > b) { temp = c; }
    return temp;
}
```

Copy Code

This mutant removes theÂ `if`Â statement that comparesÂ `b`Â andÂ `a`. The test case(s) that cover the case whereÂ `b`Â is the largest number will fail to notice the mutation.  
è¿™ä¸ªçªå˜ä½“åˆ é™¤äº†æ¯”è¾ƒÂ `b`Â å’ŒÂ `a`Â çš„Â `if`Â è¯­å¥ã€‚æ¶µç›–Â `b`Â æ˜¯æœ€å¤§æ•°å­—çš„æƒ…å†µçš„æµ‹è¯•ç”¨ä¾‹å°†æ— æ³•æ³¨æ„åˆ°çªå˜ã€‚

To determine the kill rate of the test suite on each mutant, we need to run the test suite on each mutant and observe how many mutants are killed (i.e. detected and rejected by the test suite) and how many survive (i.e. not detected and accepted as equivalent by the test suite).  
ä¸ºäº†ç¡®å®šæµ‹è¯•å¥—ä»¶å¯¹æ¯ä¸ªçªå˜ä½“çš„æ€ä¼¤ç‡ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸ªçªå˜ä½“ä¸Šè¿è¡Œæµ‹è¯•å¥—ä»¶å¹¶è§‚å¯Ÿæœ‰å¤šå°‘çªå˜ä½“è¢«æ€æ­»ï¼ˆå³æ£€æµ‹åˆ°å¹¶è¢«æµ‹è¯•å¥—ä»¶æ‹’ç»ï¼‰å’Œå¤šå°‘å­˜æ´»ï¼ˆå³æœªæ£€æµ‹åˆ°å¹¶æ¥å—ï¼‰ä¸æµ‹è¯•å¥—ä»¶ç­‰æ•ˆï¼‰ã€‚

Assuming that the test suite has enough test cases to cover all possible scenarios, here are the expected kill rates:  
å‡è®¾æµ‹è¯•å¥—ä»¶æœ‰è¶³å¤Ÿçš„æµ‹è¯•ç”¨ä¾‹æ¥è¦†ç›–æ‰€æœ‰å¯èƒ½çš„åœºæ™¯ï¼Œè¿™é‡Œæ˜¯é¢„æœŸçš„æ€ä¼¤ç‡ï¼š

1.  `ror`Â - Relational operator replacement: The kill rate of this mutant should be lower than 100%, because some test case(s) will fail to detect the mutation when all three integers are equal. The expected kill rate depends on the distribution of integers in the test cases. If the test cases cover cases where all three integers are different, the expected kill rate should be close to 100%. If the test cases cover cases where two or three integers are equal, the expected kill rate will be lower.  
    `ror`Â - å…³ç³»è¿ç®—ç¬¦æ›¿æ¢ï¼šè¿™ä¸ªçªå˜ä½“çš„æ€æ­»ç‡åº”è¯¥ä½äº 100%ï¼Œå› ä¸ºå½“æ‰€æœ‰ä¸‰ä¸ªæ•´æ•°éƒ½ç›¸ç­‰æ—¶ï¼Œä¸€äº›æµ‹è¯•ç”¨ä¾‹å°†æ— æ³•æ£€æµ‹åˆ°çªå˜ã€‚é¢„æœŸçš„æ€ä¼¤ç‡å–å†³äºæµ‹è¯•ç”¨ä¾‹ä¸­æ•´æ•°çš„åˆ†å¸ƒã€‚å¦‚æœæµ‹è¯•ç”¨ä¾‹æ¶µç›–äº†æ‰€æœ‰ä¸‰ä¸ªæ•´æ•°éƒ½ä¸åŒçš„æƒ…å†µï¼Œåˆ™é¢„æœŸçš„æ€æ­»ç‡åº”è¯¥æ¥è¿‘ 100%ã€‚å¦‚æœæµ‹è¯•ç”¨ä¾‹æ¶µç›–ä¸¤ä¸ªæˆ–ä¸‰ä¸ªæ•´æ•°ç›¸ç­‰çš„æƒ…å†µï¼Œåˆ™é¢„æœŸçš„æ€æ­»ç‡ä¼šæ›´ä½ã€‚
    
2.  `vie`Â - Variable initialization elimination: The kill rate of this mutant should be 100% if the test suite has enough test cases to cover all possible scenarios. The mutation is relatively simple and affects only one variable. A well-designed test suite should be able to detect this mutation.  
    `vie`Â - å˜é‡åˆå§‹åŒ–æ¶ˆé™¤ï¼šå¦‚æœæµ‹è¯•å¥—ä»¶æœ‰è¶³å¤Ÿçš„æµ‹è¯•ç”¨ä¾‹æ¥è¦†ç›–æ‰€æœ‰å¯èƒ½çš„åœºæ™¯ï¼Œé‚£ä¹ˆè¿™ä¸ªçªå˜ä½“çš„æ€ç­ç‡åº”è¯¥æ˜¯100%ã€‚çªå˜ç›¸å¯¹ç®€å•ï¼Œåªå½±å“ä¸€ä¸ªå˜é‡ã€‚ä¸€ä¸ªè®¾è®¡è‰¯å¥½çš„æµ‹è¯•å¥—ä»¶åº”è¯¥èƒ½å¤Ÿæ£€æµ‹åˆ°è¿™ç§çªå˜ã€‚
    
3.  `sdl`Â - Statement deletion: The kill rate of this mutant should be lower than 100%, because some test case(s) will fail to detect the mutation when all three integers are equal or whenÂ `b`Â is the largest number. The expected kill rate depends on the distribution of integers in the test cases. If the test cases cover cases whereÂ `a`Â is the largest number or whereÂ `c`Â is larger thanÂ `b`Â andÂ `a`, the expected kill rate should be close to 100%. If the test cases cover cases whereÂ `b`Â is the largest number, the expected kill rate will be lower.  
    `sdl`Â - è¯­å¥åˆ é™¤ï¼šè¿™ä¸ªçªå˜ä½“çš„æ€æ­»ç‡åº”è¯¥ä½äº100%ï¼Œå› ä¸ºå½“æ‰€æœ‰ä¸‰ä¸ªæ•´æ•°éƒ½ç›¸ç­‰æˆ–è€…Â `b`Â æ˜¯æœ€å¤§æ•°æ—¶ï¼Œä¸€äº›æµ‹è¯•ç”¨ä¾‹å°†æ— æ³•æ£€æµ‹åˆ°çªå˜ã€‚é¢„æœŸçš„æ€ä¼¤ç‡å–å†³äºæµ‹è¯•ç”¨ä¾‹ä¸­æ•´æ•°çš„åˆ†å¸ƒã€‚å¦‚æœæµ‹è¯•ç”¨ä¾‹æ¶µç›–Â `a`Â æ˜¯æœ€å¤§æ•°å­—æˆ–Â `c`Â å¤§äºÂ `b`Â å’ŒÂ `a`Â çš„æƒ…å†µï¼Œåˆ™é¢„æœŸçš„æ€ç­ç‡åº”æ¥è¿‘ 100%ã€‚å¦‚æœæµ‹è¯•ç”¨ä¾‹æ¶µç›–Â `b`Â æ•°é‡æœ€å¤šçš„ç”¨ä¾‹ï¼Œåˆ™é¢„æœŸçš„æ€ç­ç‡ä¼šæ›´ä½ã€‚

# Quiz11
![](../img/fit5171-20230518.jpg)