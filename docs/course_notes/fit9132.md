Create time: 2022-05-05  Last update: 2022-12-05

# How to use the FIT study Note document
1. download the [markdown file repository](https://github.com/GreenH47/mynote) and  navigate to the `docs` folder
2. view all the markdown files via [Obsidian vault](https://help.obsidian.md/How+to/Working+with+multiple+vaults) that can show the linked section in the note document  ![](../img/5032-20221103.png)  
3. You may find some extra material or program template  repository in the Course Brief introduction for the FIT Note markdown Document (some course don't have )

4. you can view [the web page](https://greenh47.github.io/mynote/) which transfer from MD file online but will lose the extra information or wrong    markdown display

  
# FIT9132 Course Brief introduction

[FIT9132 - Introduction to databases](https://handbook.monash.edu/2022/units/FIT9132?year=2022) done for the year 2022. (Semester 1)  

# WEEK 1
ER Modeling
![](../img/fit9132-20221205.png)


Logical Model  
![](../img/fit9132-20221205-1.png)

Physical Model
![](../img/fit9132-20221205-3.png)


# week 2 Conceptual Modelling
  
ç†è§£æ•°æ®åº“è®¾è®¡çš„å„ä¸ªé˜¶æ®µ
ç†è§£ANSI/SPARCç»“æ„åœ¨æ•°æ®åº“è®¾è®¡ä¸­çš„â»†â¾Š
è®¤è¯†å®ä½“å…³ç³»å›¾å½“ä¸­çš„å„ä¸ªç»„æˆéƒ¨åˆ†
ç†è§£strong/weak entityä¹‹é—´çš„ä¸åŒ
å­¦ä¹ ç»˜åˆ¶æ¦‚å¿µæ¨¡å‹å›¾

### ER diagram

### Entities
![](../img/fit9132-20221205-4.png)
![](../img/fit9132-20221205-5.png)

#### Strong Entity
Has a key which may be defined without reference to other entities  
![](../img/fit9132-20221205-6.png)

####  Weak Entity
Has a key which requires the existence of one or more other entities.  
For example FAMILY entity - need to include the key of employee to create a suitable key for family
![](../img/fit9132-20221205-7.png)

### Relationship
#### Identifying
 â–ª  Identifier of A is part of identifier of B
â–ª  Shown with solid line
â–ª  ENROLMENT - STUDENT Enrolment key includes student id,which is an identifier of student.  
![](../img/fit9132-20221205-9.png)

#### Non-identifying 
â–ª Identifier of A is NOT part of identifier of B.
â–ª Shown with broken line
â–ª Department no (identifier of department) is not part of Employeeâ€™s identifier
![](../img/fit9132-20221205-10.png)

### Attributes
#### Simple
Cannot be subdivided 
Age, sex, marital status

#### Composite
Can be subdivided into additional attributes
Address into street, city

#### Single-valued
Can have only a single value
 Person has one social security number

#### Multi-valued
Can have many values
Person may have several college degrees

####  Derived
Can be derived with algorithm
 Age can be derived from date of birth

#### Multivalued Attribute
An attribute that has a list of values.
Car colour may consist of body colour, trim colour, bumper colour.
![](../img/fit9132-20221205-12.png)

### ERD 
#### Step 1 Identify Main Entities
![](../img/fit9132-20221205-13.png)
#### STEP 2: Identify the relationships which exist between these entities  
(remember to add an appropriate verb)
![](../img/fit9132-20221205-14.png)
#### Step 3 Add Non-Key Attributes
![](../img/fit9132-20221205-16.png)


# WEEK 3 Relational Database Model
â€¢ Explain the relational model and its components
â€¢ Identify and evaluate the issues of insert, update and delete anomalies
â€¢ Define entity and referential integrity
â€¢ Differentiate the types of keys and distinguish their roles in the relational model
â€¢ Formulate and write relational algebra to solve query scenarios

Basic structure is the mathematical concept of a RELATION mapped to the  'concept' of a table (tabular representation of relation)  
â€“ Relation - abstract object  
â€“ Table - pictorial representation  
â€“ Storage structure - "real thing" - eg. isam file of 1's and 0's

## A Relation
A relation consists of two parts  
â€“ heading  â€“ body
Relation heading â‡¨ column headings  
Relation body â‡¨ set of data rows
### Relation Heading â‡¨ column headings  
Also called Relational Schema consists of a fixed set of attributes  

 `R (A1,A2,.......An)  
`R = relation name, Ai = attribute i` 

Each attribute corresponds to one underlying domain:  
 Customer relation heading:  
	 CUSTOMER (custno, custname, custadd, custcredlimit)
		dom(custno) = customer_number

###  Relation Body â‡¨ set of data rows

### Relation Properties
#### No duplicate tuples
sets do not contain duplicate elements   hence tuples must be unique

#### Tuples are unordered within a relation
sets are not ordered   hence tuples can only be accessed by content

#### No ordering of attributes within a tuple
#### Tuple values are atomic - cannot be divided
 `EMPLOYEE (eid, ename, departno, dependants) `
	 not allowed: `dependants (dep_name, dep_age) `multivalued hence no multivalued (repeating) attributes allowed, called the first  normal form rule

### Functional Dependency
A set of attributes A functionally determines an attribute B if, and only if, for  each A value, there is exactly one value of B in the relation. It is denoted as 

<mark style="background: #0000CD;">A  â†’ B (A determines B, or B depends on A)</mark>

## Relational Model Keys
###   superkey
A superkey of a relation R is an attribute or set of attributes which exhibits only  the uniqueness property  
â€“ No two tuples of R have the same value for the superkey (Uniqueness  property)  
â€“ t1[superkey] â‰  t2[superkey]
### candidate key (CK)
A candidate key (CK) of a relation R is an attribute or set of attributes which  exhibits the following properties:  
â€“ <mark style="background: #ff0000;">Uniqueness property (as above)</mark>, and  
â€“ No proper subset of CK has the uniqueness property  (Minimality or Irreducibility property) ie. a minimal superkey
â€“<mark style="background: #3CB371;"></mark>One candidate key is chosen to be the primary key (PK) of a relation
### Primary key
<mark style="background: #D2691E;">One candidate key is chosen to be the primary key (PK) of a relation
preferably a single attribute, preferably numeric</mark>

![](../img/fit9132-20221205-17.png)

### Null
NULL is NOT a value - is a representation of the fact that there is NO VALUE
VALUE NOT APPLICABLE
VALUE UNKNOWN
VALUE DOES NOT EXIST
VALUE UNDEFINED

### Writing Relations
Relations may be represented using the following notation:  
â€“ RELATION_NAME (attribute1, attribute2,...)  
â–ª Relation_name must not be pluralised (is a set name)  
â–ª The primary key is underlined.  
`STAFF (staff_id, staff_surname, staff_initials, staff_address,  staff_phone)`

### Foreign Key (FK)
An attribute/s in a relation that exists in the same, or another relation  as a Primary Key  

### Data Integrity
==Entity integrity==
Primary key value must not be NULL.  
â€¢ No duplicate tuple property then ensures that each primary key  must be unique  
â€¢ Implemented in the RDBMS via a unique index on the PK

==Referential integrity==
â€“ The values of FK must either match a value of a full PK in the  related relation or be NULL.  

==Column/Domain integrity==
â€“ All values in a given column must come from the same domain  (the same data type and range)

## Relational Algebra
8 basic operations:  
â€“ single relation: 
â€¢ selection,â€¢  projection  

â€“ two relations:  
â€¢ cartesian product, join  â€¢ union  
â€¢ intersection  â€¢ difference  â€¢ division

### PROJECT ğ¿
![](../img/fit9132-20221205-18.png)

### SELECT ğˆ
![](../img/fit9132-20221205-19.png)

### Multiple Actions
![](../img/fit9132-20221205-21.png)

### NATURAL JOIN
Step 1: STUDENT X MARK
![](../img/fit9132-20221205-22.png)

Step 2: delete rows where IDs do not match (select =)
![](../img/fit9132-20221205-23.png)

Step 3: delete duplicate columns (project away)
![](../img/fit9132-20221205-24.png)

### UNION, INTERSECT, DIFFERENCE
![](../img/fit9132-20221205-26.png)

## quiz and exercise
![](../img/fit9132-20221205-27.png)
![](../img/fit9132-20221205-30.png)
![](../img/fit9132-20221205-31.png)
![](../img/fit9132-20221205-32.png)

# week 4 Normalisation
â€¢ç†è§£åœ¨æ•°æ®åº“è®¾è®¡ä¸­è¿›â¾æ•°æ®è§„èŒƒåŒ–çš„åŸå› 
â€¢ç†è§£åœ¨æ•°æ®è§„èŒƒåŒ–ä¸­å„ç§ä¸åŒç±»å‹çš„dependencyçš„å®šä¹‰
â€¢ç†è§£åœ¨æ•°æ®è§„èŒƒåŒ–ä¸­ä»UNFåˆ°3NFçš„å„ä¸ªæ­¥éª¤
â€¢æ³¨æ„åˆ°æ›´â¾¼é˜¶çš„æ•°æ®è§„èŒƒåŒ–ï¼ˆBoyce Codd, 4NFå’Œ5NFï¼‰
â€¢å¯ä»¥é€šè¿‡ç»™å®šçš„relationç”»å‡ºdependencyå›¾
â€¢å¯ä»¥å¯¹ç»™å‡ºçš„æ•°æ®åº“æè¿°è¿›â¾æ•°æ®è§„èŒƒåŒ–çš„æ“ä½œ
â€¢å¯ä»¥é€šè¿‡ç»™å®šçš„é€»è¾‘ç­‰çº§çš„å›¾æ ‡è¿›â¾å¿«é€Ÿæ•°æ®è§„èŒƒåŒ–

Data Normalisation  
â–ª Relations MUST be normalised in order to avoid anomalies which may  occur when inserting, updating and deleting data.  
â–ª Normalisation is a systematic series of steps for progressively refining the  data model.  
â–ª A formal approach to analysing relations based on their primary key /  candidate keys and functional dependencies

Used:  
â–ª as a design technique=="bottom up design"==, and  
â–ª as a way of validating structures produced via =="top down design" (ER model  converted to a logical model - see next week)==  
â–ª for this unit only concerned with conversion to third normal form 

## The Normalisation Process Goals
Creating valid relations, i.e. each relation meets the properties of the  relational model. In particular:  
â€“ Entity integrity  â€“ Referential integrity  
â€“ No many-to-many relationship  
â€“ Each cell contains a single value (is atomic)
åˆ›å»ºæœ‰æ•ˆå…³ç³»ï¼Œå³æ¯ä¸ªå…³ç³»éƒ½æ»¡è¶³å…³ç³»æ¨¡å‹çš„å±æ€§ã€‚ç‰¹åˆ«æ˜¯ï¼š â€“ å®ä½“å®Œæ•´æ€§ â€“ å‚ç…§å®Œæ•´æ€§ â€“ æ²¡æœ‰å¤šå¯¹å¤šå…³ç³» â€“ æ¯ä¸ªå•å…ƒæ ¼åŒ…å«ä¸€ä¸ªå€¼ï¼ˆæ˜¯åŸå­çš„ï¼‰
  
In practical terms when implemented in an RDBMS:  
â€“ Each table represents a single subject  
â€“ No data item will be unnecessarily stored in more than one table (remember  some redundancy still exists - minimal redundancy).  
â€“ The relationship between tables can be established (via PK and FK pairs).  
â€“ Each table is void of insert, update and delete anomalies.  
å®é™…ä¸Šï¼Œå½“åœ¨ RDBMS ä¸­å®ç°æ—¶ï¼š â€“ æ¯ä¸ªè¡¨ä»£è¡¨ä¸€ä¸ªä¸»é¢˜ â€“ æ²¡æœ‰æ•°æ®é¡¹å°†ä¸å¿…è¦åœ°å­˜å‚¨åœ¨å¤šä¸ªè¡¨ä¸­ï¼ˆè®°ä½ä¸€äº›å†—ä½™ä»ç„¶å­˜åœ¨ - æœ€å°å†—ä½™ï¼‰ã€‚ â€“ å¯ä»¥å»ºç«‹è¡¨ä¹‹é—´çš„å…³ç³»ï¼ˆé€šè¿‡ PK å’Œ FK å¯¹ï¼‰ã€‚ â€“ æ¯ä¸ªè¡¨éƒ½æ²¡æœ‰æ’å…¥ã€æ›´æ–°å’Œåˆ é™¤å¼‚å¸¸ã€‚ 

## Representing a form as a relation
This process follows a standard approach:  
â€“ arrive at a name for the form which indicates what it represents (its subject)  
â€“ determine if any attribute is multivalued (repeating) for a given entity  instance of the forms subject if an attribute (or set of attributes) appears multiple times then the group  of related attributes need to be shown enclosed in brackets to indicate  there are multiple sets of these values for each instance
æ­¤è¿‡ç¨‹éµå¾ªæ ‡å‡†æ–¹æ³•ï¼š â€“ ä¸ºè¡¨å•æŒ‡å®šä¸€ä¸ªåç§°ï¼Œè¡¨æ˜å…¶ä»£è¡¨ä»€ä¹ˆï¼ˆå…¶ä¸»é¢˜ï¼‰ â€“ ç¡®å®šè¡¨å•ä¸»é¢˜çš„ç»™å®šå®ä½“å®ä¾‹çš„ä»»ä½•å±æ€§æ˜¯å¦æ˜¯å¤šå€¼ï¼ˆé‡å¤ï¼‰å¦‚æœä¸€ä¸ªå±æ€§ï¼ˆæˆ–ä¸€ç»„å±æ€§ï¼‰å‡ºç°å¤šæ¬¡ï¼Œåˆ™éœ€è¦å°†ç›¸å…³å±æ€§ç»„æ˜¾ç¤ºåœ¨æ‹¬å·ä¸­ï¼Œä»¥æŒ‡ç¤ºæ¯ä¸ªå®ä¾‹æœ‰å¤šç»„è¿™äº›å€¼

example
`DRUG_SLSREP (drug_code, drug_name, slsrep_id, slsrep_name,  slsrep_mobile)`
è¯¥è¡¨æ ¼ç”±åˆ†é…ç»™é”€å”®ä»£è¡¨æ•°æ®çš„é‡å¤è¯å“è¡Œï¼ˆå®ä¾‹ï¼‰ç»„æˆ 


## Dependency
### Functional Dependency Revisited
â–ª An attribute B is FUNCTIONALLY DEPENDENT on another attribute A, if a  value of A determines a single value of B at any one time.
`CUSTNUMB â” CUSTNAME  ORDERNO â” ORDERDATE`


### Functional Dependency
#### TOTAL DEPENDENCY  
â€“ attribute A determines B AND attribute B determines A  
`â€¢ EMPLOYEE-NUMBER â” TAX-FILE-NUMBER  â€¢ TAX-FILE-NUMBER â” EMPLOYEE-NUMBER`

#### FULL DEPENDENCY  
occurs when an attribute is always dependent on all attributes in the  composite PK  
`ORDERNO, PRODNO â” QTYORDERED`

#### PARTIAL  DEPENDENCY  
Lack of full dependency for multiple attribute key 
`ORDERNO, PRODNO  â” PRODDESC, QTYORDERED`
â€“ here although qtyordered is fully dependent on orderno and prodno, only  prodno is required to determine proddesc  
â€“ proddesc is said to be partially dependent on orderno and prodno

####   TRANSITIVE DEPENDENCY
occurs when Y depends on X, and Z depends on Y - thus Z also depends on  X ie. X â” Y â” Z  
â€“ and Y is not a candidate key (or part of a candidate key)  
`ORDERNO â” CUSTNUMB â” CUSTNAME`

å½“ Y ä¾èµ–äº X å¹¶ä¸” Z ä¾èµ–äº Y æ—¶å‘ç”Ÿ - å› æ­¤ Z ä¹Ÿä¾èµ–äº X å³ã€‚ X â” Y â” Z â€“ Y ä¸æ˜¯å€™é€‰é”®ï¼ˆæˆ–å€™é€‰é”®çš„ä¸€éƒ¨åˆ†ï¼‰

## Normal Form
### UNF 
![](../img/fit9132-20221205-34.png)

### 1NF
A RELATION IS IN FIRST NORMAL FORM (1NF)  IF:  
â€¢ a unique primary key has been identified for each tuple/row.  
â€¢ it is a valid relation  
â€“ Entity integrity (no part of PK is null)  
â€“ Single value for each cell ie. no repeating group  (multivalued attribute).  
â€¢ all attributes are functionally dependent on all or part of the  primary key

å¦‚æœï¼š â€¢ å·²ä¸ºæ¯ä¸ªå…ƒç»„/è¡Œæ ‡è¯†äº†å”¯ä¸€çš„ä¸»é”®ï¼Œåˆ™å…³ç³»ä¸ºç¬¬ä¸€èŒƒå¼ (1NF)ã€‚ â€¢ è¿™æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å…³ç³» â€“ å®ä½“å®Œæ•´æ€§ï¼ˆPK çš„ä»»ä½•éƒ¨åˆ†éƒ½ä¸ä¸ºç©ºï¼‰ â€“ æ¯ä¸ªå•å…ƒæ ¼çš„å•ä¸ªå€¼ï¼Œå³ã€‚æ²¡æœ‰é‡å¤ç»„ï¼ˆå¤šå€¼å±æ€§ï¼‰ã€‚ â€¢ æ‰€æœ‰å±æ€§åœ¨åŠŸèƒ½ä¸Šéƒ½ä¾èµ–äºå…¨éƒ¨æˆ–éƒ¨åˆ†ä¸»é”®

### UNF to 1NF
â€“  identifying a unique identifier for the repeating group.  
â€“ remove any repeating group along with the PK of the main relation.  
â€“ The PK of the new relation resulting from the removal of repeating  group will normally have a composite PK made up of the PK of the  main relation and the unique identifier chosen in 1. above, but this  must be checked
æ ‡è¯†é‡å¤ç»„çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚ 
åˆ é™¤ä»»ä½•é‡å¤ç»„ä»¥åŠä¸»è¦å…³ç³»çš„ PKã€‚ 
åˆ é™¤é‡å¤ç»„äº§ç”Ÿçš„æ–°å…³ç³»çš„ PK é€šå¸¸ä¼šæœ‰ä¸€ä¸ªå¤åˆ PKï¼Œç”±ä¸»å…³ç³»çš„ PK å’Œä¸Šé¢ 1. ä¸­é€‰æ‹©çš„å”¯ä¸€æ ‡è¯†ç¬¦ç»„æˆï¼Œ
![](../img/fit9132-20221205-37.png)
![](../img/fit9132-20221205-38.png)

### 1NF to 2NF
all non key attributes are functionally dependent on the primary key  
â€“ all non key attributes are functionally dependent on any candidate  key 
æ‰€æœ‰éé”®å±æ€§åœ¨åŠŸèƒ½ä¸Šä¾èµ–äºä¸»é”®
æ‰€æœ‰éé”®å±æ€§åœ¨åŠŸèƒ½ä¸Šä¾èµ–äºä»»ä½•å€™é€‰é”®
![](../img/fit9132-20221205-40.png)

### 2NF to 3NF
Move from 2NF to 3NF by removing transitive dependencies  
â€“ Remove the attributes with transitive dependency into a new relation.  
â€“ The determinant will be an attribute in both the original and new  relations (it will become a PK / FK relationship)  
â€“ Assign the determinant to be the PK of the new relation
åˆ é™¤ä¼ é€’ä¾èµ–ä» 2NF ç§»åŠ¨åˆ° 3NFâ€”â€”å°†å…·æœ‰ä¼ é€’ä¾èµ–çš„å±æ€§åˆ é™¤åˆ°æ–°å…³ç³»ä¸­ã€‚ â€“ è¡Œåˆ—å¼å°†æ˜¯åŸå§‹å…³ç³»å’Œæ–°å…³ç³»ä¸­çš„å±æ€§ï¼ˆå®ƒå°†æˆä¸º PK / FK å…³ç³»ï¼‰ â€“ å°†è¡Œåˆ—å¼åˆ†é…ä¸ºæ–°å…³ç³»çš„ PK
![](../img/fit9132-20221205-41.png)

### summary
  
<mark style="background: #3CB371;">UNF to 1NF define PK & remove repeating group.  
1NF to 2NF remove partial dependency.  
2NF to 3NF remove transitive dependency.  
UNF åˆ° 1NF å®šä¹‰ PK å¹¶åˆ é™¤é‡å¤ç»„ã€‚ 
1NF åˆ° 2NF æ¶ˆé™¤éƒ¨åˆ†ä¾èµ–ã€‚
2NF åˆ° 3NF æ¶ˆé™¤äº†ä¼ é€’ä¾èµ–ã€‚</mark>

![](../img/fit9132-20221205-42.png)
![](../img/fit9132-20221205-43.png)
![](../img/fit9132-20221205-44.png)
![](../img/fit9132-20221205-45.png)
![](../img/fit9132-20221205-46.png)



# week 5 Logical Modelling
Define the steps taken to map an ER diagram to a relational model
 Map an ER diagram to a relational model
Use SQL Developer - Data Modeler to draw a logical level ER diagram

## Relational Model Characteristics
Each relation must have a unique name  
â–ª Each attribute of a relation must have a distinct name within the relation  
â–ª An attribute cannot be multivalued (consist of repeating values)  
â–ª All values of an attribute need to be from the same domain  
â–ª The order of attributes and tuples in a relation is immaterial  
â–ª Each relation must have a primary key  
â–ª Logical (not physical) connections are made between relations by virtue  
of primary/foreign key pairing


## Transforming ER diagrams into relations
Essentially  
â€“ KEY to PK  
â€“ Represent relationships with PK/FK pairs

â–ª The steps are:  
â€“ Map strong (regular) entities  
â€“ Map weak entities  
â€“ Map binary relationships  
â€“ Map associative entities  
â€“ Map unary relationships  
â€“ Map ternary relationships

### Mapping a Composite Attribute
![](../img/fit9132-20221205-49.png)

### Mapping a Multi valued Attribute
![](../img/fit9132-20221205-50.png)

### Mapping a Weak Entity
For each weak entity type, create a new relation and include all of the simple  attributes as attributes of this relation. The PK of the identifying relation is  also included as the FK in this new relation

![](../img/fit9132-20221205-51.png)

### Mapping a 1:M Binary Relationship
For each 1:M binary relationship, first create a relation for each of the  two entity types participating in the relationship. Then include the PK  attribute (or attributes) of the entity on the one-side of the relationship  as the FK on the many-side of the relationship
å¯¹äºæ¯ä¸ª 1:M äºŒå…ƒå…³ç³»ï¼Œé¦–å…ˆä¸ºå‚ä¸è¯¥å…³ç³»çš„ä¸¤ä¸ªå®ä½“ç±»å‹ä¸­çš„æ¯ä¸€ä¸ªåˆ›å»ºä¸€ä¸ªå…³ç³»ã€‚ç„¶åå°†å®ä½“çš„PKå±æ€§ï¼ˆæˆ–å±æ€§ï¼‰åŒ…å«åœ¨å…³ç³»çš„ä¸€ä¾§ä½œä¸ºå…³ç³»çš„å¤šä¾§çš„FK
![](../img/fit9132-20221205-52.png)


### Mapping a M:N Binary Relationship
First create a relation for each of the two entity types participating in the relationship.  
â€“ Then create a new relation and include as foreign key attributes, the PK  attribute (or attributes) for each of the two participating entity types. These  attributes become the PK of the new relation.  
â€“ If there are any nonkey attributes associated with the M:N relationship, they  are also included in the new relation.  
é¦–å…ˆä¸ºå‚ä¸å…³ç³»çš„ä¸¤ä¸ªå®ä½“ç±»å‹ä¸­çš„æ¯ä¸€ä¸ªåˆ›å»ºä¸€ä¸ªå…³ç³»ã€‚ â€“ ç„¶ååˆ›å»ºä¸€ä¸ªæ–°å…³ç³»ï¼Œå¹¶å°†ä¸¤ä¸ªå‚ä¸å®ä½“ç±»å‹ä¸­çš„æ¯ä¸€ä¸ªçš„ PK å±æ€§ï¼ˆæˆ–å¤šä¸ªå±æ€§ï¼‰ä½œä¸ºå¤–é”®å±æ€§åŒ…æ‹¬åœ¨å†…ã€‚è¿™äº›å±æ€§æˆä¸ºæ–°å…³ç³»çš„PKã€‚ â€“ å¦‚æœæœ‰ä»»ä½•ä¸ M:N å…³ç³»å…³è”çš„éå…³é”®å±æ€§ï¼Œå®ƒä»¬ä¹ŸåŒ…å«åœ¨æ–°å…³ç³»ä¸­ã€‚ 

![](../img/fit9132-20221205-53.png)
![](../img/fit9132-20221205-54.png)

### Mapping an associative entity with an Identifier
![](../img/fit9132-20221205-55.png)

### Mapping a 1:M Unary Relationship
![](../img/fit9132-20221205-56.png)

### Mapping a M:N Unary Relationship
![](../img/fit9132-20221205-58.png)



# week6 Creating & Populating the Database
Map an ER diagram to a relational model  

Use SQL Developer - Data Modeler to draw a logical level ER diagram, map it to the  relational model and generate a schema file

## CREATE A TABLE (DDL)

![](../img/fit9132-20221205-59.png)

### Alternative (BETTER) method of defining FKs
![](../img/fit9132-20221205-61.png)

### ALTER TABLE
Used to change a tables structure.  
â–ª For example:  
â€“ Adding column(s).  
â€“ Removing column(s).  
â€“ Adding constraint(s) - used previously for FK's, but can be any constraint  
â€“ Removing constraint(s)
![](../img/fit9132-20221205-62.png)

### ALTER TABLE_Manipulate Constraints
Turn constraint ON or OFF to temporarily disable
![](../img/fit9132-20221205-65.png)

Remove/re add constraint to modify constraint
![](../img/fit9132-20221205-67.png)

### DROP_DELETING A TABLE
`DROP TABLE training_course PURGE`
`DROP TABLE trainer CASCADE CONSTRAINTS PURGE;`

## ADDING TUPLES/ROWS TO A TABLE (DML)
### INSERT_Adding data to table
![](../img/fit9132-20221205-68.png)
#### (TO_DATE)Inserting DATES into a table
convert a date
`to_date('06 Apr 2022','dd Mon yyyy')`
convert a date and time
`to_date('06/04/2022 17:00','dd/mm/yyyy hh:mi')`
convert a time
`to_date('17:00','hh:mi')`
Insert a rental into the RENTAL table
`insert into RENTAL (rent_no, rent_bond, rent_out, rent_in,drone_id, ct_id) values (123, 250,to_date('06 Apr 2022 10:00','dd Mon yyyy hh:mi'), null,234, 2345);`

### COMMIT and ROLLBACK
COMMIT makes the changes to the database permanent.  ROLLBACK will undo the changes.  COMMIT/ROLLBACK only applicable to INSERT/UPDATE and DELETE

### (SEQUENCE) auto-increment of a numeric
Create sequence
`CREATE SEQUENCE manuf_seq ` 
`INCREMENT BY 1;`

Access the sequence using two built-in variables
`INSERT INTO manufacturer`
`VALUES(manuf_seq.nextval,'DJI');`




# WEEK 7 Structured Query Language (SQL)
Create tables in a database  
Add new records to a table  
Use ORACLE's sequences to generate keys  
Remove tables from a database
## SELECT
### Anatomy of an SQL SELECT Statement
![](../img/fit9132-20221205-69.png)
![](../img/fit9132-20221205-70.png)
###   Comparison
Compare the value of one expression to the value of another expression
`=, !=,< >, <, >, <=, >=`
`  drone_pur_price > 2000`

### BETWEEN_Range
test whether the value of an expression falls within a specified range of  values
`drone_pur_price BETWEEN 3000 AND 5300`
(both are inclusive)

### IN_Set Membership
test whether the value of expression equals one of a set of value
`dt_code in ('DMA2','DSPA') `

### LIKE_Pattern Match
whether a string (text) matches a specified pattern

% character represents any sequence of zero or more character
`WHERE dt_model LIKE 'DJI%'`(drone type models starting with DJI)

_ character represents any single character
`WHERE train_code LIKE '__I__' `(drone types with a train_code with  an I in the middle)

### AND, OR, NOT
An expression is evaluated LEFT to RIGHT  
Sub-expression in brackets are evaluated first  
NOTs are evaluated before AND and OR  
ANDs are evaluated before OR  
Use of BRACKETS better alternative  

AND is evaluated to be TRUE if and only if both conditions are TRUE  
â€¢ OR is evaluated to be TRUE if and only if at least one of the conditions  is TRUE
![](../img/fit9132-20221205-71.png)

### NVL_replace a NULL with a value
It is used to replace a NULL with a value (numeric OR character/string)
`SELECT stu_nbr`
	`NVL(enrol_mark,0),`
	`NVL(enrol_grade,'WH')`
`FROM enrolment; `
![](../img/fit9132-20221205-72.png)
`select rent_no, drone_id,  `
`to_char(rent_out,'dd-Mon-yyyy') as dateout, `
`nvl(to_char(rent_in,'dd-Mon-yyyy'),'Still out')  as datein  `
`from rental;`


`select rent_no, drone_id, rent_out, `
`nvl(rent_in,'Still out') from rental;`
![](../img/fit9132-20221205-73.png)


### AS_Renaming Column
`select drone_id, drone_cost_hr/60 as costpermin  from drone;`

### (ORDER BY)Sorting Query Result
==Must be used if more than one row may be returned==
Order can be ASCending or DESCending. The default is ASCending
`select drone_id, drone_flight_time `
`from drone`
`order by `
`drone_flight_time desc, drone_id;`
![](../img/fit9132-20221205-74.png)
### (DISTINCT)removing Duplicate Rows in the Query Result
`select distinct drone_id  `
`from rental  `
`order by drone_id;`
![](../img/fit9132-20221205-75.png)

### TO_CHAR
Text representing date must be formatted  with TO_DATE when comparing or  inserting/updating
`select to_char(sysdate,'dd-Mon-yyyy') from dual; = 20-Apr-2021`
`select  to_char(sysdate,'dd-Mon-yyyy hh:mi:ss AM')  from dual; = 0-Apr-2020 02:51:24 PM `
![](../img/fit9132-20221205-77.png)




## JOIN
placing the join in the where clause is not acceptable
### JOIN ON
the general form which always works
`from aaa JOIN bbb ON aaa.a = bbb.b`
`from aaa JOIN bbb ON aaa.key = bbb.key`
![](../img/fit9132-20221205-78.png)

### JOIN USING
requires matching attribute/s in the two tables
`FROM trainer JOIN training_course USING (trainer_id)`


### NATURAL JOIN
requires matching attribute/s in the two tables
`FROM trainer NATURAL JOIN training_course`
![](../img/fit9132-20221205-80.png)

### Different Types of SQL JOINs
 `(INNER) JOIN`: Returns records that have matching values in both tables
  `LEFT (OUTER) JOIN`: Returns all records from the left table, and the matched records from the right table
  `RIGHT (OUTER) JOIN`: Returns all records from the right table, and the matched records from the left table
  `FULL (OUTER) JOIN`: Returns all records when there is a match in either left or right table
![](../img/fit9132-20221205-81.png)



# week8 DML Update, Delete and Transaction  Management
interpret a graphical representation of a relational database  
â— code simple SQL statements on a single table  
â— code SQL statements that use rows from more than a single table using different types of  
ANSI standard JOIN operations  
â— code SQL SELECT statements to select rows based on different conditions  
â— use ORACLE's date data type in SQL statements correctly  
â— define an alias for tables and columns  
â— sort the retrieved data into different orders via SQL ORDER BY
è§£é‡Šå…³ç³»æ•°æ®åº“çš„å›¾å½¢è¡¨ç¤º â— åœ¨å•ä¸ªè¡¨ä¸Šç¼–å†™ç®€å•çš„ SQL è¯­å¥ â— ä½¿ç”¨ä¸åŒç±»å‹çš„ ANSI æ ‡å‡† JOIN æ“ä½œä½¿ç”¨å¤šä¸ªè¡¨ä¸­çš„è¡Œç¼–å†™ SQL è¯­å¥ â— ç¼–å†™ SQL SELECT è¯­å¥ä»¥æ ¹æ®ä¸åŒæ¡ä»¶é€‰æ‹©è¡Œâ— åœ¨ SQL è¯­å¥ä¸­æ­£ç¡®ä½¿ç”¨ ORACLE çš„æ—¥æœŸæ•°æ®ç±»å‹ â— ä¸ºè¡¨å’Œåˆ—å®šä¹‰åˆ«å â— é€šè¿‡ SQL ORDER BY å°†æ£€ç´¢åˆ°çš„æ•°æ®æ’åºä¸ºä¸åŒçš„é¡ºåº

# FINAL
## SQL

# SQL FINAL
![](../img/fit9132-20221205-82.png)


```sql
/*
1. Display the full details of employees who earn less than $1000, order the output  by  the employee number.
*/

SELECT
    empno,
    empname,
    empinit,
    empjob,
    to_char(empbdate,'dd Mon yyyy'),
    empmsal,
    empcomm,
    deptno,
    mgrno
FROM
    payroll.employee
WHERE
    empmsal < 1000
ORDER BY
    empno;

```

```sql
/*
2. List the department number of departments that have employees, order the output by the department number .
*/

SELECT DISTINCT
    deptno
FROM
    payroll.employee
ORDER BY deptno;
```

```sql
/*
3. Display the full details of trainers (employee job is TRAINER) who earn less than 2500 each month and are working in department 20. Order the output by  employee number.
*/

SELECT
    empno,
    empname,
    empinit,
    empjob,
    to_char(empbdate,'dd Mon yyyy'),
    empmsal,
    empcomm,
    deptno,
    mgrno
FROM
    payroll.employee
WHERE
    upper(empjob) = 'TRAINER'
    AND empmsal < 2500
    AND deptno = 20
ORDER BY
    empno;
```

```sql
/*
4. Display the name, job, monthly salary and commission of employees whose monthly salary is higher than their commission. Rename the columns: Name, Job, Monthly Salary and Commission. Order the output by name and within name by descending monthly salary.
*/

SELECT
    empname  AS "Name",
    empjob   AS "Job",
    empmsal  AS "Monthly Salary",
    empcomm  AS "Commission"
FROM
    payroll.employee
WHERE
    empmsal > empcomm
ORDER BY
    empname,
    empmsal DESC;
```

```sql
/*
5. Display the name and job of employees whose job ends with the letter R. Order the output by name and within name by job.
*/

SELECT
    empname,
    empjob
FROM
    payroll.employee
WHERE
    upper(empjob) LIKE '%R'
ORDER BY
    empname,
    empjob;
```

```sql
/*
6. Display the name and job of employees that have a name starting with â€œJâ€, â€œKâ€ or â€œMâ€. Order the output by name and within name by job.
*/

SELECT
    empname,
    empjob
FROM
    payroll.employee
WHERE
        upper(empname) LIKE 'J%'
    OR
        upper(empname) LIKE 'K%'
    OR
        upper(empname) LIKE 'M%'
ORDER BY
    empname,
    empjob;
```

```sql
/*
7. Display the name, job, date of birth and monthly salary of employees who were born before 1990 and earn more than 1500 each month. Order the output by name and within name by monthly salary.
*/

SELECT
    empname,
    empjob,
    to_char(empbdate, 'Dd-Mon-YYYY') AS birthdate,
    empmsal
FROM
    payroll.employee
WHERE
        empbdate < TO_DATE('01-JAN-1990', 'dd-MON-YYYY')
    AND empmsal > 1500
ORDER BY
    empname,
    empmsal;
```

```sql
/*
8. Display the name, job, date of birth and salary of employees that don't have a commission. Order the output by name, and within name by date of birth.
*/

SELECT
    empname,
    empjob,
    to_char(empbdate, 'Dd-Mon-YYYY') AS birthdate,
    empmsal
FROM
    payroll.employee
WHERE
    empcomm IS NULL
ORDER BY
    empname,
    empbdate;
```

```sql
/*
9. Display the employee name, job, department name, location and monthly salary of employees that work in NEW YORK. Order the output by name, and within name by job.
*/

SELECT
    e.empname,
    e.empjob,
    d.deptname,
    d.deptlocation,
    e.empmsal
FROM
    payroll.employee e join payroll.department d on e.deptno = d.deptno
WHERE
    upper(d.deptlocation) = 'NEW YORK'
ORDER BY e.empname;
```

```sql
/*
10. Display the name and job of employees who do not work in NEW YORK or CHICAGO. Order the output by name, and within name by job.
*/

SELECT
    e.empname,
    e.empjob,
    d.deptname,
    d.deptlocation
FROM
         payroll.employee e
    JOIN payroll.department d
    ON e.deptno = d.deptno
WHERE
    upper(d.deptlocation) NOT IN ( 'NEW YORK', 'CHICAGO' )
ORDER BY
    e.empname,
    empjob;
```

```sql
/*
11. Display the name, job, date of birth and salary of employees who were born in the first half of the 70s. Display the output in birth date order and within birthdate by name.
*/

SELECT
    empname,
    empjob,
    to_char(empbdate, 'Dd-Mon-YYYY') AS birthdate,
    empmsal
FROM
    payroll.employee
WHERE
    empbdate BETWEEN TO_DATE('01-JAN-1970', 'DD-MON-YYYY') AND TO_DATE('31-DEC-1974',
    'DD-MON-YYYY')
ORDER BY
    empbdate,
    empname;
```

```sql
/* 
12.  Display the name, job and salary of employees who earn less than 1500 or greater than 3000 per month. Order the output by name, and within name by monthly salary.
*/

SELECT
    empname,
    empjob,
    empmsal
FROM
    payroll.employee
WHERE
    empmsal NOT BETWEEN 1500 AND 3000
ORDER BY
    empname,
    empmsal;
```

```sql
/* 
13. Display the name, job and manager number of employees who have a manager. 
Order the output by manager number and within a given manager by employee name.
*/

SELECT
    empname,
    empjob,
    mgrno
FROM
    payroll.employee
WHERE
    mgrno IS NOT NULL
ORDER BY
    mgrno,
    empname;
```

```sql
/*
14. Display the name, job, department name, department location and monthly salary of employees who either work in DALLAS or as a MANAGER, and earn more than 2500. Order the output by name and within name by monthly salary.
*/

SELECT
    e.empname,
    e.empjob,
    d.deptname,
    d.deptlocation,
    e.empmsal
FROM
         payroll.employee e
    JOIN payroll.department d
    ON ( e.deptno = d.deptno )
WHERE
    ( upper(d.deptlocation) = 'DALLAS'
      OR upper(e.empjob) = 'MANAGER' )
    AND e.empmsal > 2500
ORDER BY
    e.empname,
    empmsal;
```

```sql
/*
15. Display the name, job, monthly salary and salary grade of all employees. Display the list in monthly salary order within salary grade order.
*/

SELECT
    e.empname,
    e.empjob,
    e.empmsal,
    s.salgrade
FROM
    payroll.employee e
    JOIN payroll.salgrade s ON (
        e.empmsal BETWEEN s.sallower AND s.salupper
    )
ORDER BY
    s.salgrade,
    e.empmsal;
```

```sql
/*
16. Display the name and location of ALL departments, and the name of their employees. Display the output in employee name order within department name order.
*/

SELECT
    d.deptname,
    d.deptlocation,
    e.empname
FROM
    payroll.employee e
    RIGHT OUTER JOIN payroll.department d ON (
        e.deptno = d.deptno
    )
ORDER BY
    d.deptname,
    e.empname;
```

```sql
/*
17. Display the name of ALL employees, their job and the name of their manager. List the output in employee name order within manager name order.
*/

SELECT
    e.empname "Employee",
    e.empjob AS "Emp Job",
    m.empname AS "Manager"
FROM
    payroll.employee e
    LEFT OUTER JOIN payroll.employee m ON (
        e.mgrno = m.empno
    )
ORDER BY
    m.empname,
    e.empname;
/*
-- here NVL(m.empname,'NA') could be used to display a value rather than leave the managers name null for the director
*/
```

```sql
/*
18. For each employee display their employment history. In the listing include the employeesâ€™ name, the name of the department they worked for, the begin and end date and their monthly salary. Display the output in begin date order (most recent at the top of the list) within employee name order.
*/

SELECT
    e.empname,
    d.deptname,
    to_char(histbegindate,'DD-Mon-YYY') as HISTBEGIN,
    to_char(histenddate,'Dd-Mon-YYYY') as HISTEND,
    h.histmsal
FROM
    payroll.employee e
    JOIN payroll.history h ON (
        e.empno = h.empno
    )
    JOIN payroll.department d ON (
        d.deptno = h.deptno
    )
ORDER BY
    e.empname,
    h.histbegindate DESC;
```

```sql
/*
19. Display the employee name, empjob, monthly salary and annual salary of all employees (annual salary is monthly salary x 12). Order the output by annual salary with the highest value shown first and within annual salary by name.
*/

SELECT
    empname,
    empjob,
    empmsal,
    empmsal * 12 AS "Annual Salary"
FROM
    payroll.employee
ORDER BY
    "Annual Salary" DESC,
    empname;
```

```sql
/*
20. Display the employee name, empjob, monthly salary, empcommission and annual income (salary and empcommission) of all employees. Commission is paid on a monthly basis. Order the output by name,and within by annual income.
*/

SELECT
    empname,
    empjob,
    empmsal,
    empcomm,
    12 * ( empmsal + nvl(empcomm, 0) ) AS "Annual Income"
FROM
    payroll.employee
ORDER BY
    empname,
    "Annual Income";
```

```sql
/*
1. Display for all employees their number, name, job, monthly salary, their current annual salary (not including commission) and what their annual salary would be if they were given a 10% pay rise. Order the output by employee number.
*/

SELECT
    empno,
    empname,
    empjob,
    empmsal,
    empmsal * 12          AS annual_salary,
    empmsal * 12 * 1.1    AS ann_sal_with_rise
FROM
    payroll.employee
ORDER BY
    empno;
```

```sql
/*
2. Display the name of all employees, their birthdate and their age in years. Order the output by birthdate, within birthdate order the output by name.
*/

SELECT
    empname,
    to_char(empbdate, 'DD-Mon-YYYY')                       AS birthdate,
    floor(months_between(sysdate, empbdate) / 12)          AS "Age in Yrs"
FROM
    payroll.employee
ORDER BY
    empbdate,
    empname;
```

```sql
/*
3. Display for all employees, their number, name, job, monthly salary, commission (which is paid monthly) and their current annual salary (including commission). Order the output by  employee number.
*/

SELECT
    empno,
    empname,
    empjob,
    empmsal,
    empcomm,
    ( empmsal + nvl(empcomm, 0) ) * 12 AS total_salary
FROM
    payroll.employee
ORDER BY
    empno;
```

```sql
/*
4. Display all employees details in the following format: EMPLOYEE N. Smith IS A Trainer AND WORKS IN THE Training DEPARTMENT.

INITCAP() å‡½æ•°å°†æ¯ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯è®¾ç½®ä¸ºå¤§å†™ï¼Œæ‰€æœ‰å…¶ä»–å­—æ¯è®¾ç½®ä¸ºå°å†™ã€‚å•è¯ç”±ç©ºæ ¼æˆ–éå­—æ¯æ•°å­—å­—ç¬¦åˆ†éš”ã€‚

SELECT INITCAP('steven king') "Emp. Name"  
FROM DUAL;

>> Emp. Name
-----------
Steven King
*/
SELECT
    'EMPLOYEE '
     || empinit
     || '. '
     || initcap(empname)
     || ' IS A '
     || initcap(empjob)
     || ' AND WORKS IN THE '
     || initcap(deptname)
     || ' DEPARTMENT.' as empdetails
FROM
    payroll.employee e
    JOIN payroll.department d ON (
        e.deptno = d.deptno
    )
ORDER BY empname;

SELECT
    'EMPLOYEE '
     || empinit
     || '. '
     || initcap(empname)
     || ' IS A '
     || initcap(nvl(empjob,'----'))
     || ' AND WORKS IN THE '
     || initcap(nvl(deptname,'----'))
     || ' DEPARTMENT.' as empdetails
FROM
    payroll.employee e
    left outer JOIN payroll.department d ON (
        e.deptno = d.deptno
    )
ORDER BY e.empno;
```

```sql
/*
5. Display the name of all employees, their birthdate and their age in months. Order the output by age in months (with the oldest employee first), within age in months order the output by name. The age in months must be shown with one decimal point and right aligned.
*/

SELECT
    empname,
    to_char(empbdate, 'dd-Mon-yyyy')                                     AS birthdate,
    lpad(to_char(months_between(sysdate, empbdate), '990.0'), 10)        AS age_in_months
FROM
    payroll.employee
ORDER BY
    age_in_months DESC,
    empname;

/*
LPAD() å‡½æ•°ç”¨å¦ä¸€ä¸ªå­—ç¬¦ä¸²å‘å·¦å¡«å……ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¾¾åˆ°ä¸€å®šçš„é•¿åº¦ã€‚
SELECT LPAD("SQL Tutorial", 20, "ABC");
>> ABCABCABSQL Tutorial
*/
```

```sql
/*
6. Display the employees who were born in February. Order the output by employeename.


EXTRACT() Extract the month from a date:

SELECT EXTRACT(MONTH FROM "2017-06-15");
>> 6
*/

SELECT
    empname,
    to_char(empbdate, 'dd-Mon-yyyy') AS birthdate
FROM
    payroll.employee
WHERE
    EXTRACT(MONTH FROM empbdate) = 2
ORDER BY
    empname;
```

```sql
  
/*
7. Display the employee name, salary and commission (using the GREATEST function) for those employees who earn more commission than their monthly salary. Order the output by employee name and within name by monthly take home pay (salary plus commission).

GREATEST() Return the greatest value of the list of arguments:
*/

SELECT
    empname,
    empmsal,
    empcomm
FROM
    payroll.employee
WHERE
    empcomm = greatest(empcomm, empmsal)
ORDER BY
    empname,
    ( empmsal + empcomm );
    
```

```sql
/*
8. Display the name of all employees and their birthdate in the following format: EMPLOYEE N. Smith was born on FRIDAY the 17 of DECEMBER , 1982. Order the output by employee name.

Â INITCAP() å‡½æ•°å°†æ¯ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯è®¾ç½®ä¸ºå¤§å†™ï¼Œæ‰€æœ‰å…¶ä»–å­—æ¯è®¾ç½®ä¸ºå°å†™ã€‚å•è¯ç”±ç©ºæ ¼æˆ–éå­—æ¯æ•°å­—å­—ç¬¦åˆ†éš”

RTRIM() ä»å­—ç¬¦ä¸²ä¸­åˆ é™¤å°¾éšç©ºæ ¼ï¼š

SELECT RTRIM('SQL Tutorial Â   ') AS RightTrimmedString;
>>SQL Tutorial
*/

SELECT
    'EMPLOYEE '
     || empinit
     || '. '
     || initcap(empname)
     || ' was born on '
     || rtrim(TO_CHAR(empbdate,'DAY') )
     || ' the '
     || EXTRACT(DAY FROM empbdate)
     || ' of '
     || rtrim(TO_CHAR(empbdate,'MONTH') )
     || ','
     || EXTRACT(YEAR FROM empbdate) as "EMP DOB Details"
FROM
    payroll.employee
ORDER BY 
    empname;
```

```sql
/*
9. Display the name of the employees who have registered for a course and the
number of times they have registered. Order the output by employee number.

`GROUP BY`è¯­å¥å°†å…·æœ‰ç›¸åŒå€¼çš„è¡Œåˆ†ç»„åˆ°æ±‡æ€»è¡Œä¸­ï¼Œä¾‹å¦‚â€œæŸ¥æ‰¾æ¯ä¸ªå›½å®¶/åœ°åŒºçš„å®¢æˆ·æ•°é‡â€ã€‚

`GROUP BY`è¯­å¥é€šå¸¸ä¸èšåˆå‡½æ•° (Â `COUNT()`,Â `MAX()`,Â `MIN()`,Â `SUM()`,Â `AVG()`) ä¸€èµ·ä½¿ç”¨ï¼Œä»¥æŒ‰ä¸€åˆ—æˆ–å¤šåˆ—å¯¹ç»“æœé›†è¿›è¡Œåˆ†ç»„
SELECTÂ _column_name(s)_  
FROMÂ _table_name_  
WHEREÂ _condition_  
GROUPÂ BYÂ _column_name(s)  
ORDERÂ BYÂ _column_name(s);_

SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
ORDER BY COUNT(CustomerID) DESC;

>>COUNT(CustomerID) Country
13USA

11Germany

11France

*/

SELECT
    e.empno,
    e.empname,
    COUNT(*) AS nbr_registrations
FROM
         payroll.employee e
    JOIN payroll.registration r
    ON ( e.empno = r.empno )
GROUP BY
    e.empno,
    e.empname
ORDER BY
    empno;
```

```sql
/*
10. Who is the oldest employee? Show the employee number, name and date of birth. Order the output by employee number.
*/

SELECT
    empno,
    empname,
    to_char(empbdate, 'DD-Mon-YYYY')
FROM
    payroll.employee
WHERE
    empbdate = (
        SELECT
            MIN(empbdate)
        FROM
            payroll.employee
    )
ORDER BY
    empno;
```

```sql
/*
11. For each department, list the department number and name, the number of employees, the minimum and maximum monthly salary, the total monthly salary and the average salary paid to their employees. Name the columns: NbrOfEmployees, MinSalary, MaxSalary, TotalSalary, AvgSalary. Order the output by department number.
*/

SELECT
    d.deptno,
    d.deptname,
    COUNT(e.empno)                           "NbrOfEmployees",
    MIN(empmsal)                             "MinSalary",
    MAX(empmsal)                             "MaxSalary",
    SUM(empmsal)                             "TotalSalary",
    to_char(AVG(empmsal), '9999.99')          "AvgSalary"
FROM
    payroll.employee      e
    RIGHT OUTER JOIN payroll.department    d
    ON ( e.deptno = d.deptno )
GROUP BY
    d.deptno,
    d.deptname
ORDER BY
    deptno;
```

```sql
/*
12. Display the department number, jobs available in that department and the total monthly salary paid for each job. Order the output by department number and within a department by job.
*/

SELECT
    deptno,
    empjob,
    SUM(empmsal)
FROM
    payroll.employee
GROUP BY
    deptno,
    empjob
ORDER BY deptno,empjob;
```

```sql
/*
13. Which employee earns more than the average salary? Show the employee number, name and monthly salary. Order the output by employee number.
*/

SELECT
    empno,
    empname,
    empmsal
FROM
    payroll.employee
WHERE
    empmsal > (
        SELECT
            AVG(empmsal)
        FROM
            payroll.employee
    )
ORDER BY 
    empno;
```

```sql
/*
14. Which department has the greatest average monthly salary? Show the department no, name and average monthly salary. Order the output by department number.

ROUND() å‡½æ•°å°†æ•°å­—å››èˆäº”å…¥åˆ°æŒ‡å®šçš„å°æ•°ä½æ•°
SELECT ROUND(235.415, 2) AS RoundValue;
>>RoundValue
235.420
*/

SELECT
    d.deptno,
    d.deptname,
    round(AVG(empmsal),2) "AvgSalary"
FROM
    payroll.employee e
    JOIN payroll.department d ON (
        e.deptno = d.deptno
    )
GROUP BY
    d.deptno,
    d.deptname
HAVING
    AVG(empmsal) = (
        SELECT
            MAX(AVG(empmsal) )
        FROM
            payroll.employee
        GROUP BY
            deptno
    )
ORDER BY 
    deptno;
```

```sql
/*
15. Which course has the most offerings? Show the course code, description and number of offerings. Order the output by the number of offerings in descending order and within the number of offerings by the course code.
*/

SELECT
    c.crscode,
    c.crsdesc,
    COUNT(*) "NbrOfferings"
FROM
         payroll.course c
    JOIN payroll.offering o
    ON ( c.crscode = o.crscode )
GROUP BY
    c.crscode,
    c.crsdesc
HAVING
    COUNT(*) = (
        SELECT
            MAX(COUNT(*))
        FROM
            payroll.offering
        GROUP BY
            crscode
    )
ORDER BY
    COUNT(*) DESC,
    crscode;
```

```sql
/*
16. Display the name, job and date of birth of employees who perform the same job as SCOTT and were born in the same year. Do not include SCOTT in the output. Order the output by employee name. 
*/

SELECT
    e.empname,
    e.empjob,
    to_char(empbdate, 'dd-Mon-yyyy')
FROM
    payroll.employee e
WHERE
        ( e.empjob,
          EXTRACT(YEAR FROM empbdate) ) = (
            SELECT
                e.empjob,
                EXTRACT(YEAR FROM empbdate)
            FROM
                payroll.employee e
            WHERE
                upper(empname) = 'SCOTT'
        )
    AND upper(e.empname) <> 'SCOTT'
ORDER BY
    empname;
```

```sql
/*
17. Using the MINUS statement, which employees have never registered in a course. Show their employee number and name. Order the output by employee number.

`SELECT DISTINCT`è¯­å¥ç”¨äºä»…è¿”å›ä¸åŒï¼ˆä¸åŒï¼‰çš„å€¼ã€‚
åœ¨è¡¨ä¸­ï¼Œä¸€åˆ—é€šå¸¸åŒ…å«è®¸å¤šé‡å¤å€¼ï¼›æœ‰æ—¶æ‚¨åªæƒ³åˆ—å‡ºä¸åŒçš„ï¼ˆä¸åŒçš„ï¼‰å€¼ã€‚
SELECTÂ DISTINCTÂ _column1_,Â _column2, ..._  
FROMÂ _table_name_;
*/

SELECT
    empno,
    empname
FROM
    payroll.employee
MINUS
SELECT DISTINCT
    e.empno,
    empname
FROM
         payroll.registration r
    JOIN payroll.employee e
    ON ( r.empno = e.empno )
ORDER BY
    empno;
```

```sql
/*
18. Using the INTERSECT statement, which employees have both registered for and conducted courses. Show the employee number and name. Order the output by employee number.
*/

SELECT DISTINCT
    e.empno AS "TrainerAndStudent",
    empname
FROM
         payroll.offering o
    JOIN payroll.employee e
    ON ( o.empno = e.empno )
INTERSECT
SELECT DISTINCT
    e.empno,
    empname
FROM
         payroll.registration r
    JOIN payroll.employee e
    ON ( r.empno = e.empno )
ORDER BY
    "TrainerAndStudent";
```
